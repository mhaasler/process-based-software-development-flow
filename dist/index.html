<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8" />
  <title>PSE Galaxy</title>
  <script src="https://unpkg.com/vis-network/standalone/umd/vis-network.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
  <style>
    body {
      margin: 0;
      font-family: system-ui;
      background: #0d1117;
      color: #e6edf3;
    }

    #network {
      width: 100vw;
      height: 100vh;
    }

    #info {
      position: absolute;
      right: 20px;
      top: 20px;
      width: 380px;
      background: #161b22;
      padding: 15px;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
      font-size: 14px;
      max-height: calc(100vh - 40px);
      overflow: auto;
      z-index: 10;
      top: 80px;
    }

    #toolbar {
      position: absolute;
      left: 20px;
      top: 20px;
      background: #161b22;
      padding: 10px 12px;
      border-radius: 8px;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
      display: flex;
      gap: 10px;
      align-items: center;
      font-size: 14px;
      flex-wrap: wrap;
      z-index: 20;
    }

    select,
    input,
    button {
      background: #0d1117;
      color: #e6edf3;
      border: 1px solid #30363d;
      border-radius: 6px;
      padding: 6px 8px;
    }

    input {
      width: 220px;
    }

    button {
      cursor: pointer;
    }

    button[disabled] {
      opacity: 0.5;
      cursor: not-allowed;
    }

    h3 {
      margin: 0 0 10px;
    }

    .muted {
      color: #9da7b1;
      font-size: 12px;
    }

    code {
      background: #0d1117;
      padding: 2px 4px;
      border-radius: 4px;
    }

    .legend {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .swatch {
      width: 90px;
      height: 10px;
      border-radius: 8px;
      border: 1px solid #30363d;
    }

    /* Suggestions dropdown */
    .searchWrap {
      position: relative;
      display: inline-block;
    }

    #suggestions {
      position: absolute;
      left: 0;
      top: 36px;
      width: 360px;
      background: #0d1117;
      border: 1px solid #30363d;
      border-radius: 8px;
      box-shadow: 0 12px 30px rgba(0, 0, 0, 0.5);
      overflow: hidden;
      display: none;
      z-index: 9999;
    }

    .sugItem {
      padding: 10px 10px;
      cursor: pointer;
      display: flex;
      gap: 10px;
      align-items: baseline;
      border-bottom: 1px solid #161b22;
    }

    .sugItem:last-child {
      border-bottom: none;
    }

    .sugItem:hover {
      background: #161b22;
    }

    .sugId {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      color: #cbd5e1;
      font-size: 12px;
    }

    .sugTitle {
      color: #e6edf3;
    }

    .sugMeta {
      margin-left: auto;
      color: #9da7b1;
      font-size: 12px;
    }

    /* Breadcrumb */
    #crumbs {
      display: flex;
      gap: 6px;
      align-items: center;
      max-width: 520px;
    }

    .crumb {
      font-size: 12px;
      color: #cbd5e1;
      cursor: pointer;
      white-space: nowrap;
      max-width: 180px;
      overflow: hidden;
      text-overflow: ellipsis;
      border: 1px solid #30363d;
      border-radius: 999px;
      padding: 3px 8px;
      background: #0d1117;
    }

    .crumb:hover {
      background: #161b22;
    }

    .crumbSep {
      color: #475569;
      font-size: 12px;
    }
  </style>
</head>

<body>

  <div id="network"></div>

  <div id="toolbar">
    <button id="backBtn" disabled title="Back">←</button>
    <div id="crumbs" title="Breadcrumb"></div>

    <span>Search:</span>
    <div class="searchWrap">
      <input id="searchInput" type="text" placeholder="id, title, tags, …" autocomplete="off" />
      <div id="suggestions"></div>
    </div>

    <span>Galaxy:</span>
    <select id="galaxySelect">
      <option value="main" selected>main</option>
      <option value="process_galaxy">process_galaxy</option>
    </select>

    <span>Gradient:</span>
    <select id="gradientSelect">
      <option value="">(none)</option>
    </select>

    <div class="legend" title="0 → 1">
      <span id="legendLeft" class="muted">0</span>
      <div id="legendSwatch" class="swatch"></div>
      <span id="legendRight" class="muted">1</span>
    </div>
  </div>

  <div id="info">Klicke einen Stern…</div>

  <script>
    async function loadText(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(url + " -> " + res.status);
      return await res.text();
    }

    function pickTitle(n) { return n.title || n.id; }
    function clamp01(x) { return Math.max(0, Math.min(1, x)); }
    function lerp(a, b, t) { return a + (b - a) * t; }

    function colorRamp01(t) {
      t = clamp01(t);
      const r = Math.round(lerp(30, 239, t));
      const g = Math.round(lerp(41, 246, t));
      const b = Math.round(lerp(59, 255, t));
      return "rgb(" + r + "," + g + "," + b + ")";
    }

    function neutralFallbackColor(node, isAnchor) {
      const isCore = node.kind === "core" || isAnchor;
      return isCore ? "rgb(120, 113, 108)" : "rgb(71, 85, 105)";
    }

    function gradientValue(node, key) {
      if (!key) return null;
      const g = node.gradients && node.gradients[key];
      if (!g) return null;
      const min = (g.min == null ? null : Number(g.min));
      const max = (g.max == null ? null : Number(g.max));
      if (min == null && max == null) return null;
      if (min == null) return clamp01(max);
      if (max == null) return clamp01(min);
      return clamp01((min + max) / 2);
    }

    function nodeSize(node, gv, isAnchor) {
      const base = (node.kind === "core" || isAnchor) ? 40 : 24;
      if (gv == null) return base;
      return base + Math.round(gv * 18);
    }

    function tooltipFor(node, gradientKey) {
      if (!gradientKey) return pickTitle(node);
      const gv = gradientValue(node, gradientKey);
      const v = (gv == null) ? "n/a" : gv.toFixed(2);
      return pickTitle(node) + "\n" + gradientKey + ": " + v;
    }

    function nodeStyle(node, gradientKey, isAnchor) {
      const gv = gradientValue(node, gradientKey);
      const color = (gv == null) ? neutralFallbackColor(node, isAnchor) : colorRamp01(gv);

      return {
        id: node.id,
        label: pickTitle(node),
        title: tooltipFor(node, gradientKey),
        shape: (node.kind === "core" || isAnchor) ? "star" : "dot",
        size: nodeSize(node, gv, isAnchor),
        color: color,
        font: { color: "#ffffff" }
      };
    }

    function edgeStyle(e) {
      const s = (e.strength == null ? 0.5 : Number(e.strength));
      const width = Math.max(1, s * 3);
      const opacity = clamp01(lerp(0.15, 0.9, s));
      return {
        id: e.from + "->" + e.to + ":" + (e.rel || ""),
        from: e.from,
        to: e.to,
        width: width,
        arrows: "to",
        color: { color: "rgb(148,163,184)", opacity: opacity }
      };
    }

    function filterGraphByGalaxy(graph, galaxy) {
      const hideRoot = !!galaxy.hide_root;
      const allowed = new Set(galaxy.stars || []);

      // Root ist Kontext: nur rendern, wenn nicht verborgen
      if (galaxy.root && !hideRoot) allowed.add(galaxy.root);

      const nodes = graph.nodes.filter(n => allowed.has(n.id));
      const edges = graph.edges.filter(e => allowed.has(e.from) && allowed.has(e.to));

      return { nodes, edges, hideRoot };
    }

    function renderInfo(node, gradientKey) {
      const planets = (node.planets || []).map(p => "<li><code>" + p + "</code></li>").join("");
      const links = (node.links || []).map(l => {
        const s = (l.strength == null ? 0.5 : l.strength);
        return "<li><code>" + l.rel + "</code> → <code>" + l.to + "</code> (" + s + ")</li>";
      }).join("");

      const body = node.body ? String(node.body).replace(/\n/g, "<br>") : "";
      const gv = gradientValue(node, gradientKey);

      const gvLine = gradientKey
        ? "<p class='muted'>Gradient <code>" + gradientKey + "</code>: <code>" + (gv == null ? "n/a" : gv.toFixed(2)) + "</code></p>"
        : "";

      document.getElementById("info").innerHTML =
        "<h3>" + pickTitle(node) + "</h3>" +
        "<div class='muted'><code>" + node.id + "</code> · kind: <code>" + node.kind + "</code> · layer: <code>" + node.layer + "</code></div>" +
        gvLine +
        "<p><strong>Kernentscheidung:</strong><br>" + (node.core_decision || "") + "</p>" +
        (node.summary ? "<p class='muted'>" + node.summary + "</p>" : "") +
        (planets ? "<p><strong>Planeten</strong></p><ul>" + planets + "</ul>" : "") +
        (links ? "<p><strong>Links</strong></p><ul>" + links + "</ul>" : "") +
        (body ? "<p><strong>Notizen</strong></p><p>" + body + "</p>" : "");
    }

    async function loadGalaxyYaml(galaxyId) {
      const yamlText = await loadText("./galaxies/" + galaxyId + ".yml");
      return jsyaml.load(yamlText);
    }

    async function loadGalaxyIndex() {
      try {
        const yamlText = await loadText("./galaxies/index.yml");
        return jsyaml.load(yamlText) || {};
      } catch {
        return {};
      }
    }

    async function loadGradientsManifest() {
      const yamlText = await loadText("./gradients/index.yml");
      const manifest = jsyaml.load(yamlText) || {};
      return manifest.gradients || [];
    }

    async function loadGradientDef(file) {
      const yamlText = await loadText("./gradients/" + file);
      return jsyaml.load(yamlText);
    }

    function setLegend(gradDef) {
      const left = document.getElementById("legendLeft");
      const right = document.getElementById("legendRight");
      const swatch = document.getElementById("legendSwatch");

      if (!gradDef) {
        left.textContent = "0";
        right.textContent = "1";
        swatch.style.background = "linear-gradient(90deg," + colorRamp01(0) + "," + colorRamp01(1) + ")";
        return;
      }
      left.textContent = gradDef.left || "0";
      right.textContent = gradDef.right || "1";
      swatch.style.background = "linear-gradient(90deg," + colorRamp01(0) + "," + colorRamp01(1) + ")";
    }

    /* Search */
    function dimNode(n) { return { id: n.id, color: { background: "rgb(51,65,85)" }, font: { color: "rgb(148,163,184)" } }; }
    function dimEdge(eid) { return { id: eid, color: { color: "rgb(100,116,139)", opacity: 0.06 } }; }
    function highlightEdge(eid, opacity) { return { id: eid, color: { color: "rgb(226,232,240)", opacity: opacity } }; }

    function buildSearchText(node) {
      const parts = [];
      parts.push(node.id || "");
      parts.push(node.title || "");
      parts.push(node.summary || "");
      parts.push(node.core_decision || "");
      if (Array.isArray(node.tags)) parts.push(node.tags.join(" "));
      return parts.join(" ").toLowerCase();
    }

    function scoreMatch(text, q) {
      if (!q) return 0;
      if (text.startsWith(q)) return 4;
      if (text.includes(" " + q)) return 3;
      if (text.includes(q)) return 1;
      return 0;
    }

    function bestMatches(filteredNodes, searchIndex, q, limit) {
      const scored = [];
      for (const n of filteredNodes) {
        const t = searchIndex[n.id] || "";
        const sc = scoreMatch(t, q);
        if (sc > 0) scored.push({ id: n.id, score: sc });
      }
      scored.sort((a, b) => b.score - a.score || a.id.localeCompare(b.id));
      return scored.slice(0, limit).map(x => x.id);
    }

    /* Breadcrumb */
    function renderBreadcrumb(history, onClick) {
      const el = document.getElementById("crumbs");
      el.innerHTML = "";
      for (let i = 0; i < history.length; i++) {
        const id = history[i];
        const crumb = document.createElement("div");
        crumb.className = "crumb";
        crumb.textContent = id;
        crumb.title = id;
        crumb.addEventListener("click", () => onClick(i));
        el.appendChild(crumb);

        if (i < history.length - 1) {
          const sep = document.createElement("div");
          sep.className = "crumbSep";
          sep.textContent = "›";
          el.appendChild(sep);
        }
      }
    }

    async function main() {
      const graph = await (await fetch("./graph.json")).json();
      const galaxyIndex = await loadGalaxyIndex();

      const galaxySelect = document.getElementById("galaxySelect");
      const gradientSelect = document.getElementById("gradientSelect");
      const searchInput = document.getElementById("searchInput");
      const suggestions = document.getElementById("suggestions");
      const backBtn = document.getElementById("backBtn");
      const container = document.getElementById("network");

      // Dynamic gradients
      const manifest = await loadGradientsManifest();
      const gradientDefs = {};
      for (const g of manifest) {
        const def = await loadGradientDef(g.file);
        gradientDefs[g.id] = def;

        const opt = document.createElement("option");
        opt.value = g.id;
        opt.textContent = def.title ? (g.id + " — " + def.title) : g.id;
        gradientSelect.appendChild(opt);
      }
      setLegend(null);

      let state = {
        filtered: null,
        nodeItems: null,
        edgeItems: null,
        nodesDS: null,
        edgesDS: null,
        network: null,
        neighborMap: null,
        originalNodes: null,
        originalEdges: null,
        searchIndex: null,
        topIds: []
      };

      // history stack for galaxies
      let galaxyHistory = [galaxySelect.value];

      function updateNavUI() {
        backBtn.disabled = galaxyHistory.length <= 1;
        renderBreadcrumb(galaxyHistory, async (idx) => {
          // jump to breadcrumb idx
          const target = galaxyHistory[idx];
          galaxyHistory = galaxyHistory.slice(0, idx + 1);
          galaxySelect.value = target;
          await loadAndRender(target, { pushHistory: false });
          applySearchFilter(searchInput.value);
          updateNavUI();
        });
      }

      function rebuildSearchIndex(filteredNodes) {
        const idx = {};
        for (const n of filteredNodes) idx[n.id] = buildSearchText(n);
        return idx;
      }

      function closeSuggestions() {
        suggestions.style.display = "none";
        suggestions.innerHTML = "";
      }

      function openSuggestions(items) {
        if (!items.length) { closeSuggestions(); return; }
        suggestions.style.display = "block";
        suggestions.innerHTML = "";
        for (const id of items) {
          const node = state.filtered.nodes.find(n => n.id === id);
          const div = document.createElement("div");
          div.className = "sugItem";
          div.dataset.nodeId = id;

          const idSpan = document.createElement("div");
          idSpan.className = "sugId";
          idSpan.textContent = id;

          const titleSpan = document.createElement("div");
          titleSpan.className = "sugTitle";
          titleSpan.textContent = node ? (node.title || "") : "";

          const meta = document.createElement("div");
          meta.className = "sugMeta";
          meta.textContent = node && node.kind ? node.kind : "";

          div.appendChild(idSpan);
          div.appendChild(titleSpan);
          div.appendChild(meta);

          div.addEventListener("mousedown", (e) => {
            e.preventDefault();
            focusNode(id);
            closeSuggestions();
          });

          suggestions.appendChild(div);
        }
      }

      function applySearchFilter(query) {
        const q = (query || "").trim().toLowerCase();
        if (!q) {
          state.topIds = [];
          closeSuggestions();
          state.nodesDS.update(state.nodeItems);
          state.edgesDS.update(state.edgeItems);
          return null;
        }

        const top = bestMatches(state.filtered.nodes, state.searchIndex, q, 5);
        state.topIds = top;
        openSuggestions(top);

        const matches = new Set(top);
        for (const n of state.filtered.nodes) {
          const t = state.searchIndex[n.id] || "";
          if (scoreMatch(t, q) > 0) matches.add(n.id);
        }

        const nodeUpdates = [];
        for (const n of state.nodeItems) {
          if (matches.has(n.id)) nodeUpdates.push({ id: n.id, ...state.originalNodes[n.id] });
          else nodeUpdates.push(dimNode(n));
        }
        state.nodesDS.update(nodeUpdates);

        const edgeUpdates = [];
        for (const e of state.edgeItems) {
          if (matches.has(e.from) && matches.has(e.to)) {
            const op = state.originalEdges[e.id].color.opacity;
            edgeUpdates.push(highlightEdge(e.id, Math.max(0.25, op)));
          } else {
            edgeUpdates.push(dimEdge(e.id));
          }
        }
        state.edgesDS.update(edgeUpdates);

        return top[0] || null;
      }

      function focusNode(nodeId) {
        const key = gradientSelect.value || "";
        const node = state.filtered.nodes.find(n => n.id === nodeId);
        if (!node) return;
        state.network.focus(nodeId, { scale: 1.25, animation: { duration: 280 } });
        state.network.selectNodes([nodeId]);
        renderInfo(node, key);
      }

      // Zoom-dive loading
      let pendingGalaxy = null;

      async function loadAndRender(galaxyId, { pushHistory } = { pushHistory: false }) {
        const galaxy = await loadGalaxyYaml(galaxyId);
        const filtered = filterGraphByGalaxy(graph, galaxy);
        const gradientKey = gradientSelect.value || "";

        const nodeItems = filtered.nodes.map(n => {
          const isAnchor = (galaxy.root && n.id === galaxy.root);
          return nodeStyle(n, gradientKey, isAnchor);
        });
        const edgeItems = filtered.edges.map(edgeStyle);

        const nodesDS = new vis.DataSet(nodeItems);
        const edgesDS = new vis.DataSet(edgeItems);

        const data = { nodes: nodesDS, edges: edgesDS };
        const options = {
          physics: {
            solver: "forceAtlas2Based",
            forceAtlas2Based: { gravitationalConstant: -80, springLength: 220, springConstant: 0.08 }
          },
          interaction: { hover: true, tooltipDelay: 100 },
          edges: { smooth: true }
        };

        container.innerHTML = "";
        const network = new vis.Network(container, data, options);

        // neighbor map (hover highlight disabled while searching)
        const neighborMap = new Map();
        for (const n of filtered.nodes) neighborMap.set(n.id, new Set());
        for (const e of edgeItems) {
          if (neighborMap.has(e.from)) neighborMap.get(e.from).add(e.to);
          if (neighborMap.has(e.to)) neighborMap.get(e.to).add(e.from);
        }

        const originalNodes = nodeItems.reduce((acc, n) => (acc[n.id] = n, acc), {});
        const originalEdges = edgeItems.reduce((acc, e) => (acc[e.id] = e, acc), {});
        const searchIndex = rebuildSearchIndex(filtered.nodes);

        state = { filtered, nodeItems, edgeItems, nodesDS, edgesDS, network, neighborMap, originalNodes, originalEdges, searchIndex, topIds: [] };

        // default info
        if (galaxy.root) {
          const rootNode = filtered.nodes.find(n => n.id === galaxy.root);
          if (rootNode) renderInfo(rootNode, gradientKey);
        } else {
          document.getElementById("info").innerHTML = "Klicke einen Stern…";
        }

        if (pushHistory) {
          const last = galaxyHistory[galaxyHistory.length - 1];
          if (last !== galaxyId) galaxyHistory.push(galaxyId);
          updateNavUI();
        }

        function applyHoverHighlight(nodeId) {
          const q = (searchInput.value || "").trim();
          if (q) return;

          const keepNodes = new Set([nodeId]);
          const neigh = neighborMap.get(nodeId) || new Set();
          for (const x of neigh) keepNodes.add(x);

          const nodeUpdates = [];
          for (const n of nodeItems) {
            if (!keepNodes.has(n.id)) nodeUpdates.push(dimNode(n));
            else nodeUpdates.push({ id: n.id, ...originalNodes[n.id] });
          }
          nodesDS.update(nodeUpdates);

          const edgeUpdates = [];
          for (const e of edgeItems) {
            const fromKeep = keepNodes.has(e.from);
            const toKeep = keepNodes.has(e.to);
            if (fromKeep && toKeep) {
              const op = originalEdges[e.id].color.opacity;
              edgeUpdates.push(highlightEdge(e.id, Math.max(0.35, op)));
            } else {
              edgeUpdates.push(dimEdge(e.id));
            }
          }
          edgesDS.update(edgeUpdates);
        }

        function clearHoverHighlight() {
          applySearchFilter(searchInput.value);
          if (!searchInput.value) {
            nodesDS.update(nodeItems);
            edgesDS.update(edgeItems);
          }
        }

        network.on("click", (params) => {
          if (!params.nodes.length) return;
          closeSuggestions();
          const nodeId = params.nodes[0];
          // Anchor node non-interactable (static star)
          if (galaxy.root && nodeId === galaxy.root) return;

          const node = filtered.nodes.find(n => n.id === nodeId);
          if (node) renderInfo(node, gradientKey);
        });

        // Double click = Dive (zoom), then load sub-galaxy after animation
        network.on("doubleClick", (params) => {
          if (!params.nodes.length) return;

          const nodeId = params.nodes[0];
          // Anchor node non-interactable
          if (galaxy.root && nodeId === galaxy.root) return;

          closeSuggestions();

          const targetGalaxy = galaxyIndex[nodeId];
          if (!targetGalaxy) return;

          pendingGalaxy = targetGalaxy;

          network.focus(nodeId, { scale: 2.2, animation: { duration: 380 } });
        });

        network.on("animationFinished", async () => {
          if (!pendingGalaxy) return;
          const toLoad = pendingGalaxy;
          pendingGalaxy = null;

          galaxySelect.value = toLoad;
          await loadAndRender(toLoad, { pushHistory: true });
          applySearchFilter(searchInput.value);
        });

        network.on("hoverNode", (params) => {
          // Anchor node: no highlight logic if desired, or keep it?
          // User said "not clickable". Let's keep hover highlight for context but no click.
          // If purely static:
          if (galaxy.root && params.node === galaxy.root) return;
          applyHoverHighlight(params.node);
        });
        network.on("blurNode", () => { clearHoverHighlight(); });

        applySearchFilter(searchInput.value);

        // Initial clean state for anchor interaction?
        // If anchor is present, maybe set its cursor to default?
        // Vis.js unfortunately doesn't support per-node cursor easily without events.
        // But preventing click/doubleClick satisfies the requirement "not clickable".
      }

      // Back button
      backBtn.addEventListener("click", async () => {
        if (galaxyHistory.length <= 1) return;
        closeSuggestions();

        galaxyHistory.pop();
        const prev = galaxyHistory[galaxyHistory.length - 1];
        galaxySelect.value = prev;

        await loadAndRender(prev, { pushHistory: false });
        applySearchFilter(searchInput.value);
        updateNavUI();
      });

      // Galaxy dropdown -> pushes history
      galaxySelect.addEventListener("change", async () => {
        closeSuggestions();
        await loadAndRender(galaxySelect.value, { pushHistory: true });
      });

      gradientSelect.addEventListener("change", async () => {
        closeSuggestions();
        const key = gradientSelect.value || "";
        setLegend(key ? gradientDefs[key] : null);
        await loadAndRender(galaxySelect.value, { pushHistory: false });
        applySearchFilter(searchInput.value);
      });

      // search handlers
      let searchTimer = null;
      searchInput.addEventListener("input", () => {
        if (searchTimer) clearTimeout(searchTimer);
        searchTimer = setTimeout(() => { applySearchFilter(searchInput.value); }, 50);
      });

      searchInput.addEventListener("focus", () => {
        applySearchFilter(searchInput.value);
      });

      searchInput.addEventListener("keydown", (e) => {
        if (e.key === "Escape") {
          searchInput.value = "";
          applySearchFilter("");
          closeSuggestions();
          e.preventDefault();
          return;
        }
        if (e.key === "Enter") {
          const bestId = state.topIds[0] || applySearchFilter(searchInput.value);
          if (!bestId) return;
          focusNode(bestId);
          closeSuggestions();
          e.preventDefault();
          return;
        }
      });

      document.addEventListener("mousedown", (e) => {
        if (e.target === searchInput || suggestions.contains(e.target)) return;
        closeSuggestions();
      });

      updateNavUI();
      await loadAndRender(galaxySelect.value, { pushHistory: false });
    }

    main().catch(err => {
      document.getElementById("info").innerHTML = "<pre>" + (err.stack || err) + "</pre>";
    });
  </script>

</body>

</html>