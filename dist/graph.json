{
  "nodes": [
    {
      "id": "actionability_and_ownership",
      "title": "Actionability & Ownership",
      "kind": "concept",
      "layer": 3,
      "summary": "Stellt sicher, dass Signale zu Handlungen führen: Zuständigkeiten, Runbooks, Eskalation, klare Verantwortungen.\n",
      "core_decision": "Wer reagiert auf welches Signal – und welche Handlungsoptionen sind definiert?\n",
      "tags": [
        "observability",
        "operations"
      ],
      "links": [
        {
          "rel": "requires",
          "to": "dashboards_and_queries",
          "strength": 0.5
        },
        {
          "rel": "drives",
          "to": "change_control",
          "strength": 0.5
        },
        {
          "rel": "triggers",
          "to": "incidents_and_postmortems",
          "strength": 0.6
        },
        {
          "rel": "requires",
          "to": "runbooks_and_playbooks",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.8
        },
        "communication_intensity": {
          "min": 0.5,
          "max": 0.8
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Jedes Signal braucht Owner + Reaktionsplan (Runbook-Light).\n- Alerts nur, wenn es eine konkrete Aktion gibt.\n- Ownership ist ein Artefakt (nicht implizit “macht schon jemand”).\n\n**Typische Failure-Modes**\n- Alerts ohne Aktion → Alarmmüdigkeit.\n- Ownership diffus → Incidents dauern länger.\n- Wissen nur im Kopf → Wiederholte Fehler.",
      "source_file": "knowledge/nodes/actionability_and_ownership.md"
    },
    {
      "id": "ai_assisted_workflow",
      "title": "KI-gestützter Workflow (Copilot/Agents)",
      "kind": "concept",
      "layer": 3,
      "summary": "Definiert, wie KI arbeitet: Kontext, Rollen, Grenzen, Review-Mechanik und wie Ergebnisse in Artefakte überführt werden.\n",
      "core_decision": "Welche Aufgaben delegieren wir an KI, und welche Regeln/Gates verhindern Drift, Halluzinationen und Security-Risiken?\n",
      "tags": [
        "tooling",
        "ai",
        "process"
      ],
      "links": [
        {
          "rel": "requires",
          "to": "artifacts_and_truth_sources",
          "strength": 0.5
        },
        {
          "rel": "requires",
          "to": "sandboxing_and_isolation",
          "strength": 0.5
        },
        {
          "rel": "is_guarded_by",
          "to": "quality_gates",
          "strength": 0.5
        },
        {
          "rel": "depends_on",
          "to": "artifacts_and_truth_sources",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.6,
          "max": 0.9
        },
        "stability": {
          "min": 0.3,
          "max": 0.6
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- KI liefert Diffs/Artefakte, nicht “nur Text”.\n- Kontext ist versioniert (Specs/Policies), nicht im Prompt versteckt.\n- Review: KI-Ergebnis ist Vorschlag, Wahrheit entsteht durch Gate + Merge.\n\n**Typische Failure-Modes**\n- KI ändert “Wahrheit” ohne Diff → Drift.\n- Zu viel Freiheit (Netz/FS/Secrets) → Security-GAU.\n- KI produziert Output ohne Vertrauensmodell → Team ignoriert es.",
      "source_file": "knowledge/nodes/ai_assisted_workflow.md"
    },
    {
      "id": "ambiguity_and_alignment",
      "title": "Ambiguität & Alignment",
      "kind": "concept",
      "layer": 3,
      "summary": "Behandelt Unsicherheit explizit: was ist unklar, wie wird entschieden, wann ist „genug Klarheit“ erreicht.\n",
      "core_decision": "Wie wird Ambiguität sichtbar gemacht und aufgelöst, ohne das System mit Overhead zu ersticken?\n",
      "tags": [
        "communication",
        "process"
      ],
      "links": [
        {
          "rel": "is_reduced_by",
          "to": "shared_language_and_models",
          "strength": 0.6
        },
        {
          "rel": "triggers",
          "to": "decision_records",
          "strength": 0.5
        },
        {
          "rel": "shapes",
          "to": "planning_and_work",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.6,
          "max": 0.9
        },
        "automatable": {
          "min": 0.2,
          "max": 0.5
        },
        "stability": {
          "min": 0.3,
          "max": 0.6
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Markiere Unsicherheit (Assumptions, Open Questions) als First-Class-Element.\n- Alignment entsteht durch kleine, überprüfbare Entscheidungen (Specs/Proofs).\n- Stop-Regeln: wann gilt etwas als entschieden (Gate/ADR/Spec-Merge).\n\n**Typische Failure-Modes**\n- Unklarheit wird ignoriert → später teure Rework-Schleifen.\n- Perfektionismus → nie „ready“, keine Execution.\n- Alignment nur sozial → keine artefaktische Absicherung.",
      "source_file": "knowledge/nodes/ambiguity_and_alignment.md"
    },
    {
      "id": "architecture_boundaries",
      "title": "Boundaries & Verantwortlichkeiten",
      "kind": "concept",
      "layer": 3,
      "summary": "Definiert, welche Teile des Systems wofür zuständig sind – und welche Abhängigkeiten verboten sind.\n",
      "core_decision": "Wo liegen die Boundaries, und welche Abhängigkeiten sind zulässig, damit Evolution kontrollierbar bleibt?\n",
      "tags": [
        "architecture",
        "structure"
      ],
      "links": [
        {
          "rel": "constrains",
          "to": "interfaces_and_contracts",
          "strength": 0.8
        },
        {
          "rel": "constrains",
          "to": "change_control",
          "strength": 0.7
        },
        {
          "rel": "is_observed_by",
          "to": "observability_design",
          "strength": 0.5
        },
        {
          "rel": "is_informed_by",
          "to": "problem_framing",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.7,
          "max": 0.95
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.8,
          "max": 1
        }
      },
      "body": "**Leitplanken**\n- Boundaries sind *Entscheidungen*: Ownership, Datenfluss, Zustandsgrenzen.\n- „Verbotene Abhängigkeiten“ explizit machen (Ports/Facades/Contracts).\n- Boundary-Entscheidungen müssen test-/lintbar sein (Gates).\n\n**Typische Failure-Modes**\n- Boundaries nur als Diagramm → im Code schleicht sich alles wieder zusammen.\n- Ownership unklar → jedes Problem wird “global”.\n- Grenzen werden pro Feature neu interpretiert → Architektur driftet.",
      "source_file": "knowledge/nodes/architecture_boundaries.md"
    },
    {
      "id": "artifacts_and_truth_sources",
      "title": "Artefakte & Truth Sources",
      "kind": "concept",
      "layer": 3,
      "summary": "Legt fest, welche Artefakte „Wahrheit“ sind (Specs, Policies, ADRs) und was nur Kommunikation/Entwurf ist.\n",
      "core_decision": "Welche Dokumente/Files haben Autorität, und wie wird verhindert, dass Wahrheit zerfasert?\n",
      "tags": [
        "communication",
        "documentation"
      ],
      "links": [
        {
          "rel": "is_expressed_in",
          "to": "specification",
          "strength": 0.6
        },
        {
          "rel": "is_referenced_by",
          "to": "decision_records",
          "strength": 0.6
        },
        {
          "rel": "is_guarded_by",
          "to": "communication_channels",
          "strength": 0.5
        },
        {
          "rel": "is_realized_by",
          "to": "specification",
          "strength": 0.6
        },
        {
          "rel": "requires",
          "to": "transparency_and_access",
          "strength": 0.3
        },
        {
          "rel": "constrains",
          "to": "ai_assisted_workflow",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.7,
          "max": 1
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.7,
          "max": 0.95
        }
      },
      "body": "**Leitplanken**\n- Eine Wahrheit pro Thema: „Single Source of Truth“ (SSOT) je Kategorie.\n- Wahrheit muss diffbar/reviewbar sein (Git) – sonst keine Governance.\n- KI darf helfen, aber nicht stillschweigend „Wahrheit umschreiben“ ohne Diff.\n\n**Typische Failure-Modes**\n- Wiki/Chat als Wahrheit → keine Versionierung, keine Review-Kontrolle.\n- Mehrere Truths → Konflikte werden politisch statt technisch gelöst.\n- Spec driftet gegen Code → Reviews verlieren Grundlage.",
      "source_file": "knowledge/nodes/artifacts_and_truth_sources.md"
    },
    {
      "id": "auditability_and_traceability",
      "title": "Auditability & Traceability",
      "kind": "concept",
      "layer": 3,
      "summary": "Stellt Nachvollziehbarkeit sicher: wer hat was geändert/entschieden, wann, warum – über Logs, Git, ADRs, Access-Audit.\n",
      "core_decision": "Welche Spuren sind verpflichtend, damit man Änderungen und Vorfälle rekonstruieren kann?\n",
      "tags": [
        "governance",
        "observability",
        "security"
      ],
      "links": [
        {
          "rel": "depends_on",
          "to": "telemetry_design",
          "strength": 0.4
        },
        {
          "rel": "depends_on",
          "to": "artifacts_and_truth_sources",
          "strength": 0.6
        },
        {
          "rel": "requires",
          "to": "transparency_and_access",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.5,
          "max": 0.85
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- “Wer/Was/Wann/Warum” ist rekonstruierbar (Git + Telemetry + Access logs).\n- Auditability ist ein Feature: Queries/Reports sind standardisiert.\n- Traceability koppelt Runs (run_id) mit Änderungen (commit, spec version).\n\n**Typische Failure-Modes**\n- Keine Spuren → Root cause unmöglich.\n- Spuren ohne Zugriff/Queries → Wissen unauffindbar.\n- Audit nur nach Incident → zu spät.",
      "source_file": "knowledge/nodes/auditability_and_traceability.md"
    },
    {
      "id": "automation_and_scripts",
      "title": "Automatisierung & Skripte (Gates, Generators)",
      "kind": "concept",
      "layer": 3,
      "summary": "Codiert Standards als Tools: Generatoren, Gates, Lint/Test-Runner, Knowledge-Gate – möglichst fail-fast.\n",
      "core_decision": "Welche Regeln müssen als Skript/Gate existieren, damit sie nicht verhandelbar sind?\n",
      "tags": [
        "tooling",
        "process"
      ],
      "links": [
        {
          "rel": "implements",
          "to": "quality_gates",
          "strength": 0.6
        },
        {
          "rel": "supports",
          "to": "planning_and_work",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.2,
          "max": 0.5
        },
        "automatable": {
          "min": 0.8,
          "max": 1
        },
        "stability": {
          "min": 0.5,
          "max": 0.85
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- “One command” für Checks (Gate-Skripte).\n- Generatoren reduzieren menschliche Variabilität (Templates, Facades, Specs).\n- Fail-fast + klare Fehlermeldungen (Fix-Hinweise).\n\n**Typische Failure-Modes**\n- Skripte sind optional → niemand nutzt sie.\n- Zu komplex → wird umgangen.\n- Keine Standard-Entry-Points → jeder macht’s anders.",
      "source_file": "knowledge/nodes/automation_and_scripts.md"
    },
    {
      "id": "change_control",
      "title": "Change Control & Evolution",
      "kind": "concept",
      "layer": 3,
      "summary": "Steuert Änderungen an Specs/Policies/Architektur über Versionierung, Review und kompatible Migrationspfade.\n",
      "core_decision": "Wie werden Änderungen kontrolliert, damit das System evolviert ohne schleichende Drift?\n",
      "tags": [
        "architecture",
        "governance"
      ],
      "links": [
        {
          "rel": "is_constrained_by",
          "to": "architecture_boundaries",
          "strength": 0.7
        },
        {
          "rel": "is_supported_by",
          "to": "quality_gates",
          "strength": 0.6
        },
        {
          "rel": "is_informed_by",
          "to": "observability_design",
          "strength": 0.6
        },
        {
          "rel": "controls",
          "to": "specification",
          "strength": 0.7
        },
        {
          "rel": "is_informed_by",
          "to": "feedback_and_learning",
          "strength": 0.6
        },
        {
          "rel": "is_documented_by",
          "to": "decision_records",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.5,
          "max": 0.8
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.7,
          "max": 0.95
        }
      },
      "body": "**Leitplanken**\n- “Spec-first”: Änderungen werden als Spec/Policy-Diff sichtbar, Code folgt.\n- Breaking Changes brauchen Migrationsstrategie (parallel run, adapters, versioned contracts).\n- Jede Änderung muss eine Beobachtungs-/Rollback-Story haben.\n\n**Typische Failure-Modes**\n- Änderungen nur im Code → Spec driftet.\n- Breaking Changes ohne Plan → Downtime/Chaos.\n- Keine Rückkopplung aus Betrieb → Evolution wird blind.",
      "source_file": "knowledge/nodes/change_control.md"
    },
    {
      "id": "communication",
      "title": "Kommunikation",
      "kind": "star",
      "layer": 1,
      "summary": "Entscheidungen darüber, wo Verständigung unverzichtbar ist und wo Artefakte Kommunikation ersetzen.",
      "core_decision": "Wo muss Verständigung explizit stattfinden – und wo reicht Verdichtung in Artefakten?",
      "tags": [
        "alignment",
        "context",
        "discussion",
        "async",
        "stakeholders"
      ],
      "galaxies": [
        "main"
      ],
      "links": [
        {
          "to": "process",
          "rel": "enables",
          "strength": 0.7
        },
        {
          "to": "structure",
          "rel": "informs",
          "strength": 0.5
        },
        {
          "to": "governance",
          "rel": "required_by",
          "strength": 0.4
        },
        {
          "to": "implementation",
          "rel": "reduced_by",
          "strength": 0.4
        },
        {
          "to": "observation_transparency",
          "rel": "guided_by",
          "strength": 0.3
        }
      ],
      "planets": [
        "architecture_conversations",
        "stakeholder_alignment",
        "async_discussion",
        "decision_rationale",
        "conflict_resolution"
      ],
      "gradients": {
        "explicitness": {
          "min": 0.2,
          "max": 0.8
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 1
        },
        "automatable": {
          "min": 0,
          "max": 0.4
        },
        "stability": {
          "min": 0.2,
          "max": 0.8
        },
        "centrality": {
          "min": 0.3,
          "max": 0.8
        }
      },
      "origin": {
        "seed": true,
        "synthetic": true,
        "external": true
      },
      "body": "- Kommunikation sinkt bei Routine-Ausführung, bleibt hoch bei Unsicherheit, Konflikten, Architektur.\n- Artefakte (Specs/ADRs) sind verdichtete Kommunikation, nicht weniger Kommunikation.\n- Kernfrage: wo findet Verständigung statt – und wie wird sie stabilisiert?",
      "source_file": "knowledge/nodes/communication.md"
    },
    {
      "id": "communication_channels",
      "title": "Kanäle & Synchronisation",
      "kind": "concept",
      "layer": 3,
      "summary": "Definiert, welche Kommunikation synchron vs asynchron läuft und wie Entscheidungen in Artefakte überführt werden.\n",
      "core_decision": "Welche Themen brauchen Sync, welche müssen Artefakt-getrieben Async sein – und wie wird das erzwungen?\n",
      "tags": [
        "communication"
      ],
      "links": [
        {
          "rel": "guards",
          "to": "artifacts_and_truth_sources",
          "strength": 0.5
        },
        {
          "rel": "reduces",
          "to": "meeting_load_and_latency",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.8
        },
        "communication_intensity": {
          "min": 0.6,
          "max": 0.9
        },
        "automatable": {
          "min": 0.3,
          "max": 0.6
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Sync ist teuer: benutze es für Ambiguität/Komplexität, nicht für Status.\n- Async braucht Artefakte (Spec/ADR/Checklist), sonst wird es „lose Meinung“.\n- Definiere Hand-off-Regeln: Chat/Meeting → ADR/Spec-Diff.\n\n**Typische Failure-Modes**\n- Alles Sync → Skalierung bricht, Entscheidungen verlangsamen.\n- Alles Async → Alignment fehlt, Missverständnisse explodieren.\n- Keine Hand-offs → Wahrheit bleibt im Gespräch stecken.",
      "source_file": "knowledge/nodes/communication_channels.md"
    },
    {
      "id": "constitution",
      "title": "Constitution (Governance Minimum)",
      "kind": "core",
      "layer": 2,
      "summary": "Oberste Regelquelle: Truth Sources, nicht verhandelbare Regeln, Change Process und verpflichtende Gates.\n",
      "core_decision": "Welche Regeln definieren Autorität und Verbindlichkeit – und wie wird ihre Einhaltung technisch erzwungen?\n",
      "tags": [
        "governance",
        "policy"
      ],
      "links": [
        {
          "rel": "is_part_of",
          "to": "governance",
          "strength": 0.7
        },
        {
          "rel": "enforces",
          "to": "policy_system",
          "strength": 0.6
        },
        {
          "rel": "is_enforced_by",
          "to": "quality_gates",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.8,
          "max": 1
        },
        "stability": {
          "min": 0.8,
          "max": 1
        },
        "centrality": {
          "min": 0.8,
          "max": 1
        }
      },
      "body": "**Leitplanken**\n- Eine Wahrheit pro Thema (Truth Sources).\n- Änderungen sind Diffs + Gate + Review.\n- KI liefert Vorschläge, Wahrheit entsteht durch Merge.\n\n**Typische Failure-Modes**\n- Regeln werden “Interpretation” statt Code/Files.\n- Gates werden optional.\n- Knowledge driftet schneller als sie gepflegt wird.",
      "source_file": "knowledge/nodes/constitution.md"
    },
    {
      "id": "core_decisions",
      "title": "Struktur- & Regelentscheidungen",
      "kind": "core",
      "layer": 0,
      "summary": "Entscheidungen über Struktur und Regeln bilden den Kern des Modells.",
      "core_decision": "Welche Strukturen und Regeln sollen gelten – und wie bleiben sie veränderbar, ohne beliebig zu werden?",
      "tags": [
        "core",
        "decisions",
        "structure",
        "rules"
      ],
      "galaxies": [
        "main"
      ],
      "links": [
        {
          "to": "structure",
          "rel": "shapes",
          "strength": 0.9
        },
        {
          "to": "process",
          "rel": "shaped_by",
          "strength": 0.8
        },
        {
          "to": "governance",
          "rel": "constrained_by",
          "strength": 0.7
        },
        {
          "to": "implementation",
          "rel": "realized_by",
          "strength": 0.8
        },
        {
          "to": "communication",
          "rel": "informed_by",
          "strength": 0.6
        },
        {
          "to": "observation_transparency",
          "rel": "evaluated_by",
          "strength": 0.7
        }
      ],
      "planets": [
        "architecture_decisions",
        "process_rules",
        "policies",
        "adr",
        "definition_of_done"
      ],
      "gradients": {
        "explicitness": {
          "min": 0.3,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.2,
          "max": 0.8
        },
        "automatable": {
          "min": 0.1,
          "max": 0.6
        },
        "stability": {
          "min": 0.3,
          "max": 0.9
        },
        "centrality": {
          "min": 0.4,
          "max": 0.9
        }
      },
      "origin": {
        "seed": true,
        "synthetic": true,
        "external": true
      },
      "body": "- Fokus: Entscheidungen über Struktur (Schnitt, Grenzen) und Regeln (Policies, Gates, DoD).\n- Diese Entscheidungen entstehen, wirken, werden beobachtet und korrigiert.\n- Mit KI verschiebt sich der Schwerpunkt von Implementierung hin zur Gestaltung von Entscheidungs- und Ausführungsprozessen.",
      "source_file": "knowledge/nodes/core_decisions.md"
    },
    {
      "id": "dashboards_and_queries",
      "title": "Dashboards & Queries",
      "kind": "concept",
      "layer": 3,
      "summary": "Definiert, wie Informationen auffindbar sind: Dashboards, Standard-Queries, Drilldowns und Debug-Playbooks.\n",
      "core_decision": "Welche Sichten/Queries müssen standardisiert sein, damit Diagnose reproduzierbar ist?\n",
      "tags": [
        "observability"
      ],
      "links": [
        {
          "rel": "is_driven_by",
          "to": "signals_and_slos",
          "strength": 0.5
        },
        {
          "rel": "supports",
          "to": "review_and_quality",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.4,
          "max": 0.7
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.5,
          "max": 0.85
        }
      },
      "body": "**Leitplanken**\n- Dashboards sind Einstiege, nicht Endpunkte: Drilldown-Queries sind wichtiger.\n- Standard-Queries versionieren (wie Code).\n- Diagnose muss reproduzierbar sein (gleiche Frage → gleiche Query).\n\n**Typische Failure-Modes**\n- Dashboard-Sprawl → niemand findet etwas.\n- Nur “schöne Charts” → keine Diagnosefähigkeit.\n- Queries nicht versioniert → Wissen geht verloren.",
      "source_file": "knowledge/nodes/dashboards_and_queries.md"
    },
    {
      "id": "data_handling_and_privacy",
      "title": "Datenhandling & Privacy",
      "kind": "concept",
      "layer": 3,
      "summary": "Legt fest, wie Daten klassifiziert, minimiert, verarbeitet und gespeichert werden (inkl. PII, Logs, Retention).\n",
      "core_decision": "Welche Daten dürfen wohin, wie lange – und wie wird das technisch abgesichert?\n",
      "tags": [
        "security",
        "privacy",
        "governance"
      ],
      "links": [
        {
          "rel": "constrains",
          "to": "telemetry_design",
          "strength": 0.5
        },
        {
          "rel": "constrains",
          "to": "artifacts_and_truth_sources",
          "strength": 0.4
        },
        {
          "rel": "aligns_with",
          "to": "transparency_and_access",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.5,
          "max": 0.85
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Data classification (PII/Secrets/Public) ist explizit und enforced.\n- Retention/Deletion ist Teil des Designs, nicht nachträglich.\n- Logging ist allowlist-basiert (was darf raus), nicht denylist-basiert.\n\n**Typische Failure-Modes**\n- PII in Logs/Traces → Compliance/Security-Fail.\n- Keine Retention → Datenhaufen, Risiko steigt.\n- “Wir anonymisieren später” → passiert nie.",
      "source_file": "knowledge/nodes/data_handling_and_privacy.md"
    },
    {
      "id": "decision_process",
      "title": "Entscheidungsprozess",
      "kind": "concept",
      "layer": 3,
      "summary": "Definiert, wie Entscheidungen entstehen: Kriterien, Beteiligung, Timebox, „Definition of Decided“.\n",
      "core_decision": "Wie werden Entscheidungen getroffen, sodass sie schnell, nachvollziehbar und korrigierbar sind?\n",
      "tags": [
        "governance",
        "process"
      ],
      "links": [
        {
          "rel": "uses",
          "to": "decision_records",
          "strength": 0.6
        },
        {
          "rel": "is_constrained_by",
          "to": "policy_system",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.6,
          "max": 0.9
        },
        "automatable": {
          "min": 0.2,
          "max": 0.5
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Entscheidungskriterien vorab (SLO, Risk, Cost, Compatibility).\n- Timebox + “owner decides” wenn nötig – sonst endlose Debatten.\n- Entscheidungen werden in Artefakte überführt (ADR/Spec/Policy).\n\n**Typische Failure-Modes**\n- Meetings ohne Entscheidungsdefinition → viel Reden, wenig Ergebnis.\n- Keine Kriterien → Entscheidung ist politisch.\n- Entscheidungen nicht dokumentiert → Wiederholungsschleifen.",
      "source_file": "knowledge/nodes/decision_process.md"
    },
    {
      "id": "decision_records",
      "title": "Entscheidungsprotokolle (ADRs)",
      "kind": "concept",
      "layer": 3,
      "summary": "Macht Architektur-/Prozess-Entscheidungen nachvollziehbar: Kontext, Optionen, Begründung, Konsequenzen.\n",
      "core_decision": "Welche Entscheidungen müssen als ADR festgehalten werden – und wann ist es Overhead?\n",
      "tags": [
        "communication",
        "governance",
        "architecture"
      ],
      "links": [
        {
          "rel": "supports",
          "to": "change_control",
          "strength": 0.6
        },
        {
          "rel": "references",
          "to": "architecture_boundaries",
          "strength": 0.5
        },
        {
          "rel": "references",
          "to": "interfaces_and_contracts",
          "strength": 0.5
        },
        {
          "rel": "feeds",
          "to": "change_control",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.2,
          "max": 0.5
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- ADRs für irreversible oder teure Entscheidungen (Boundaries, Contracts, Runtimes, Policies).\n- Kurz halten: Kontext → Entscheidung → Konsequenzen → Revisionspfad.\n- ADRs sind Link-Knoten: sie verweisen auf Specs/Policies/Code.\n\n**Typische Failure-Modes**\n- Keine ADRs → Wiederholte Debatten, keine Lernkurve.\n- ADRs als Roman → niemand liest, niemand pflegt.\n- ADRs ohne Konsequenzen → „Papierentscheidungen“.",
      "source_file": "knowledge/nodes/decision_records.md"
    },
    {
      "id": "dev_secrets_and_env",
      "title": "Dev-Secrets & Environment Hygiene",
      "kind": "concept",
      "layer": 3,
      "summary": "Regelt Secrets im Dev: lokale Stores (KeePass/Keychain), .env Policies, Masking, Rotation, keine Leaks.\n",
      "core_decision": "Wie nutzen Devs Secrets lokal, ohne sie zu kopieren/zu leaken – und wie wird das enforced?\n",
      "tags": [
        "tooling",
        "security"
      ],
      "links": [
        {
          "rel": "depends_on",
          "to": "secrets_and_passwords",
          "strength": 0.6
        },
        {
          "rel": "is_enforced_by",
          "to": "quality_gates",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.5,
          "max": 0.85
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Secrets nie in Git, nie in Logs, nie in Tickets.\n- Masking/Scanning als Gate (pre-commit oder build gate).\n- Dev-Access ist least-privilege und timeboxed, wo möglich.\n\n**Typische Failure-Modes**\n- .env im Repo → Leak.\n- Debug-Prints → Leak.\n- Shared dev credentials → kein Audit, hoher Blast Radius.",
      "source_file": "knowledge/nodes/dev_secrets_and_env.md"
    },
    {
      "id": "execution",
      "title": "Ausführung",
      "kind": "concept",
      "layer": 3,
      "summary": "Implementierung + Automatisierung: Code/Infra/Config werden erzeugt, geprüft, integriert und reproduzierbar gebaut.\n",
      "core_decision": "Welche Teile sind deterministisch ausführbar, welche benötigen menschliche Entscheidungen – und wo sind die Gates?\n",
      "tags": [
        "process",
        "seed"
      ],
      "links": [
        {
          "rel": "is_scheduled_by",
          "to": "planning_and_work",
          "strength": 0.8
        },
        {
          "rel": "produces_for",
          "to": "review_and_quality",
          "strength": 0.9
        },
        {
          "rel": "realizes",
          "to": "specification",
          "strength": 0.7
        },
        {
          "rel": "runs_under",
          "to": "runtime_execution_authority",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.4,
          "max": 0.7
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.6,
          "max": 0.9
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.7,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- „Done“ heißt: buildbar, testbar, beobachtbar – nicht „läuft auf meinem Rechner“.\n- Automatisiere wiederholbare Entscheidungen (Format, Lint, Schema, Contracts, Smoke).\n- Halte Execution deterministisch: gleiche Inputs → gleiche Outputs (so weit möglich).\n\n**Typische Failure-Modes**\n- Implizite Entscheidungen im Code/Config → später nicht mehr rekonstruierbar.\n- Lokale Sonderpfade/Manual-Fixes → CI/Review verlieren Autorität.\n- Fehlende Observability-Hooks → Feedback-Schleife bricht.",
      "source_file": "knowledge/nodes/execution.md"
    },
    {
      "id": "feedback_and_learning",
      "title": "Feedback & Lernen",
      "kind": "concept",
      "layer": 3,
      "summary": "Betriebssignale, Incidents und Nutzungserkenntnisse fließen zurück in Anforderungen, Specs, Regeln und Struktur.\n",
      "core_decision": "Wie wird aus Beobachtung eine kontrollierte Änderung (Spec/Policy/Architektur) statt ad-hoc Hotfixing?\n",
      "tags": [
        "process",
        "seed"
      ],
      "links": [
        {
          "rel": "is_yielded_by",
          "to": "review_and_quality",
          "strength": 0.7
        },
        {
          "rel": "reframes",
          "to": "problem_framing",
          "strength": 0.7
        },
        {
          "rel": "updates",
          "to": "requirements",
          "strength": 0.6
        },
        {
          "rel": "is_enabled_by",
          "to": "observability_design",
          "strength": 0.6
        },
        {
          "rel": "drives",
          "to": "change_control",
          "strength": 0.6
        },
        {
          "rel": "uses",
          "to": "signals_and_slos",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.4,
          "max": 0.7
        },
        "communication_intensity": {
          "min": 0.5,
          "max": 0.8
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.3,
          "max": 0.6
        },
        "centrality": {
          "min": 0.6,
          "max": 0.8
        }
      },
      "body": "**Leitplanken**\n- Feedback wird in Änderungen übersetzt: Spec-Change > Code-Hotfix (so oft wie möglich).\n- Definiere Signale: Welche Events/Metriken/Traces beweisen (un)erwünschtes Verhalten?\n- Lerne systematisch: Postmortems erzeugen Regeln/Checks, nicht nur „Lessons Learned“.\n\n**Typische Failure-Modes**\n- Feedback bleibt „Dashboard-Wissen“ → keine Änderungen, nur Beobachtung.\n- Incidents erzeugen schnelle Fixes → langfristig Drift und technische Unsicherheit.\n- Fehlende Kausalität → man misst viel, versteht wenig, optimiert falsch.",
      "source_file": "knowledge/nodes/feedback_and_learning.md"
    },
    {
      "id": "governance",
      "title": "Governance",
      "kind": "star",
      "layer": 1,
      "summary": "Entscheidungen darüber, wer Struktur/Regeln verändern darf und welche Sicherungen gelten.",
      "core_decision": "Wer darf welche Struktur- und Regeländerungen durchführen – unter welchen Bedingungen und mit welcher Auditierbarkeit?",
      "tags": [
        "security",
        "permissions",
        "audit",
        "policy",
        "risk"
      ],
      "galaxies": [
        "main"
      ],
      "links": [
        {
          "to": "process",
          "rel": "shapes",
          "strength": 0.6
        },
        {
          "to": "implementation",
          "rel": "constrains",
          "strength": 0.8
        },
        {
          "to": "structure",
          "rel": "protects",
          "strength": 0.6
        },
        {
          "to": "observation_transparency",
          "rel": "depends_on",
          "strength": 0.5
        },
        {
          "to": "communication",
          "rel": "requires",
          "strength": 0.4
        }
      ],
      "planets": [
        "roles",
        "permissions",
        "secrets_management",
        "sandboxing",
        "audit_trail",
        "merge_policy"
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 1
        },
        "communication_intensity": {
          "min": 0.2,
          "max": 0.7
        },
        "automatable": {
          "min": 0.3,
          "max": 0.8
        },
        "stability": {
          "min": 0.6,
          "max": 1
        },
        "centrality": {
          "min": 0.5,
          "max": 1
        }
      },
      "origin": {
        "seed": true,
        "synthetic": true,
        "external": true
      },
      "body": "- Governance beantwortet: Automatisierung – ja, aber in welchem Rahmen?\n- Hier sitzen Secrets (KeePass/Vault), Sandboxen, Rollen, Policies, Audit.\n- Gute Governance ermöglicht Geschwindigkeit ohne Kontrollverlust.",
      "source_file": "knowledge/nodes/governance.md"
    },
    {
      "id": "governance_feedback_loops",
      "title": "Governance-Feedback-Loops",
      "kind": "concept",
      "layer": 3,
      "summary": "Schließt den Kreis: Incidents, SLOs und Reviews führen zu Policy-/Gate-/Spec-Änderungen (nicht nur zu Hotfixes).\n",
      "core_decision": "Wie wird aus Beobachtung ein Governance-Update (Policy/Gate/Spec) statt ad-hoc Workarounds?\n",
      "tags": [
        "governance",
        "learning"
      ],
      "links": [
        {
          "rel": "depends_on",
          "to": "feedback_and_learning",
          "strength": 0.6
        },
        {
          "rel": "updates",
          "to": "policy_system",
          "strength": 0.5
        },
        {
          "rel": "updates",
          "to": "quality_gates",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.5,
          "max": 0.8
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Postmortems erzeugen Policy/Gate/Spec Diffs, nicht nur Tasks.\n- “Regel wird real”: neue Checks/Alerts/Runbooks folgen aus Learnings.\n- Governance misst sich am Outcome: weniger Wiederholungsfehler, schnellere Entscheidungen.\n\n**Typische Failure-Modes**\n- Learnings bleiben Folien → System bleibt unverändert.\n- Regeln ohne Messung → keine Wirkung.\n- Zu viele Feedback-Loops → Overhead ohne Priorisierung.",
      "source_file": "knowledge/nodes/governance_feedback_loops.md"
    },
    {
      "id": "implementation",
      "title": "Umsetzung",
      "kind": "star",
      "layer": 1,
      "summary": "Entscheidungen darüber, wie Regeln operativ wirksam werden (Code, Tests, Automatisierung, Agenten).",
      "core_decision": "Wie werden Struktur- und Regelentscheidungen operational wirksam – reproduzierbar, prüfbar und sicher?",
      "tags": [
        "code",
        "tests",
        "cicd",
        "automation",
        "agents"
      ],
      "galaxies": [
        "main"
      ],
      "links": [
        {
          "to": "process",
          "rel": "depends_on",
          "strength": 0.5
        },
        {
          "to": "governance",
          "rel": "constrained_by",
          "strength": 0.7
        },
        {
          "to": "observation_transparency",
          "rel": "enables",
          "strength": 0.6
        },
        {
          "to": "structure",
          "rel": "depends_on",
          "strength": 0.7
        },
        {
          "to": "communication",
          "rel": "reduced_by",
          "strength": 0.4
        }
      ],
      "planets": [
        "code",
        "tests",
        "gates",
        "cicd",
        "agent_orchestration",
        "sandbox_execution"
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 1
        },
        "communication_intensity": {
          "min": 0.1,
          "max": 0.5
        },
        "automatable": {
          "min": 0.5,
          "max": 1
        },
        "stability": {
          "min": 0.3,
          "max": 0.9
        },
        "centrality": {
          "min": 0.3,
          "max": 0.8
        }
      },
      "origin": {
        "seed": true,
        "synthetic": true,
        "external": true
      },
      "body": "- Umsetzung ist die Wirksamkeitsschicht der Entscheidungen (Ableitung, Generierung, Automatisierung).\n- Kritisch bleiben Validierbarkeit (Tests/Gates) und Begrenzung (Sandbox/Permissions).\n- Umsetzung ist nicht das Ziel, sondern die operative Konsequenz.",
      "source_file": "knowledge/nodes/implementation.md"
    },
    {
      "id": "incidents_and_postmortems",
      "title": "Incidents & Postmortems",
      "kind": "concept",
      "layer": 3,
      "summary": "Macht Störungen zu Lern- und Systemänderungen: strukturierte Diagnose, Ursachenanalyse, Maßnahmen, Nachverfolgung.\n",
      "core_decision": "Wie werden Incidents so behandelt, dass daraus systematische Verbesserungen (Specs/Policies/Gates) entstehen?\n",
      "tags": [
        "observability",
        "operations",
        "learning"
      ],
      "links": [
        {
          "rel": "is_triggered_by",
          "to": "actionability_and_ownership",
          "strength": 0.6
        },
        {
          "rel": "produces",
          "to": "feedback_and_learning",
          "strength": 0.7
        },
        {
          "rel": "produces",
          "to": "change_control",
          "strength": 0.5
        },
        {
          "rel": "is_supported_by",
          "to": "dashboards_and_queries",
          "strength": 0.5
        },
        {
          "rel": "updates",
          "to": "runbooks_and_playbooks",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.6,
          "max": 0.9
        },
        "automatable": {
          "min": 0.3,
          "max": 0.6
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Postmortems sind blameless, aber nicht folgenlos: sie erzeugen konkrete Änderungen.\n- Jede Maßnahme wird einem Artefakt zugeordnet (Spec/Policy/Gate/Runbook) und bekommt Owner+Deadline.\n- Ursache wird als Systemfehler modelliert (fehlendes Signal, fehlendes Gate, falscher Contract, fehlende Ownership).\n\n**Typische Failure-Modes**\n- Postmortem als Ritual → keine Actions, keine Veränderung.\n- „Human error“ als Enderklärung → System bleibt fragil.\n- Maßnahmen ohne Tracking → Wiederholungsfehler.",
      "source_file": "knowledge/nodes/incidents_and_postmortems.md"
    },
    {
      "id": "interfaces_and_contracts",
      "title": "Interfaces & Contracts",
      "kind": "concept",
      "layer": 3,
      "summary": "Macht Schnittstellen, Datenformen und Invarianten explizit – damit Teams/Tools unabhängig arbeiten können.\n",
      "core_decision": "Welche Contracts sind stabil genug, um Autonomie zu ermöglichen, ohne Innovation zu blockieren?\n",
      "tags": [
        "architecture",
        "structure"
      ],
      "links": [
        {
          "rel": "is_constrained_by",
          "to": "architecture_boundaries",
          "strength": 0.8
        },
        {
          "rel": "enables",
          "to": "module_composition",
          "strength": 0.7
        },
        {
          "rel": "is_validated_by",
          "to": "quality_gates",
          "strength": 0.7
        },
        {
          "rel": "is_expressed_in",
          "to": "specification",
          "strength": 0.6
        },
        {
          "rel": "is_constrained_by",
          "to": "requirements",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.7,
          "max": 1
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.5,
          "max": 0.8
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.7,
          "max": 0.95
        }
      },
      "body": "**Leitplanken**\n- Contracts sind *klein und hart*: Inputs/Outputs, Errors, Invarianten.\n- Prefer “schema + examples + tests” statt lange Prosa.\n- Versionierung/Kompatibilität explizit (breaking vs non-breaking).\n\n**Typische Failure-Modes**\n- Contracts sind “implizit im Code” → KI/Reviews raten.\n- Zu breite Interfaces → alles hängt an allem.\n- Keine Kompatibilitätsstrategie → Change wird teuer.",
      "source_file": "knowledge/nodes/interfaces_and_contracts.md"
    },
    {
      "id": "knowledge_ops_inbox_and_curation",
      "title": "Knowledge Ops (Inbox → Curation)",
      "kind": "concept",
      "layer": 3,
      "summary": "Operationalisiert Teamwissen: rohe Ideen rein, kuratierte Nodes/Links raus – via Diff, Review und Gates.\n",
      "core_decision": "Wie werden Ideen schnell erfasst, aber strukturiert in “Wahrheit” überführt, ohne dass das System vermüllt?\n",
      "tags": [
        "tooling",
        "knowledge",
        "process"
      ],
      "links": [
        {
          "rel": "depends_on",
          "to": "artifacts_and_truth_sources",
          "strength": 0.5
        },
        {
          "rel": "is_guarded_by",
          "to": "quality_gates",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Inbox ist roh und schnell; Curation ist strukturiert und reviewbar.\n- KI kuratiert als Diff (Nodes/Links/Galaxies), nicht als “Rewrite”.\n- Knowledge-Gate verhindert Broken Links und Drift.\n\n**Typische Failure-Modes**\n- Alles wird sofort “Wahrheit” → Chaos.\n- Inbox bleibt liegen → Wissen verschwindet wieder.\n- KI schreibt ungeprüft um → Autorität bricht.",
      "source_file": "knowledge/nodes/knowledge_ops_inbox_and_curation.md"
    },
    {
      "id": "least_privilege_and_access",
      "title": "Least Privilege & Access Control",
      "kind": "concept",
      "layer": 3,
      "summary": "Minimiert Rechte konsequent: Rollen, Tokens, Scope, Zeitbegrenzung, Audit – für Menschen und Systeme.\n",
      "core_decision": "Welche minimalen Rechte sind nötig – und wie werden Ausnahmen auditierbar gemacht?\n",
      "tags": [
        "security",
        "governance"
      ],
      "links": [
        {
          "rel": "constrains",
          "to": "transparency_and_access",
          "strength": 0.6
        },
        {
          "rel": "supports",
          "to": "secrets_and_passwords",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.6,
          "max": 0.9
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Rollen + kurzlebige Tokens statt “ewige” Keys.\n- Scope so klein wie möglich (read-only, env-limited, timeboxed).\n- Jede Ausnahme ist sichtbar (Audit + Owner).\n\n**Typische Failure-Modes**\n- Admin-by-default → Blast radius maximal.\n- Tokens überall wiederverwendet → lateraler Zugriff.\n- Keine Auditability → niemand merkt Missbrauch.",
      "source_file": "knowledge/nodes/least_privilege_and_access.md"
    },
    {
      "id": "local_dev_environment",
      "title": "Lokales Dev-Environment (Setup & Parität)",
      "kind": "concept",
      "layer": 3,
      "summary": "Definiert Setup, Containerisierung und Parität zu CI/Prod – damit Verhalten reproduzierbar bleibt.\n",
      "core_decision": "Wie nahe muss lokal an CI/Prod sein – und wo akzeptieren wir bewusste Abweichungen?\n",
      "tags": [
        "tooling",
        "operations"
      ],
      "links": [
        {
          "rel": "supports",
          "to": "reproducible_builds",
          "strength": 0.6
        },
        {
          "rel": "is_supported_by",
          "to": "automation_and_scripts",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.5,
          "max": 0.85
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- “One command to start” (oder wenige) – Setup ist ein Produkt.\n- Parität bewusst: welche Unterschiede sind ok (z.B. Debug, Volumes)?\n- Dokumentiere *nur* das Minimum, der Rest ist Automatisierung.\n\n**Typische Failure-Modes**\n- Setup-Drift → jeder hat “sein” System.\n- Lokale Sonderpfade → Bugs nicht reproduzierbar.\n- Onboarding dauert Tage → Team verliert Tempo.",
      "source_file": "knowledge/nodes/local_dev_environment.md"
    },
    {
      "id": "meeting_load_and_latency",
      "title": "Meeting-Last & Entscheidungs-Latenz",
      "kind": "concept",
      "layer": 3,
      "summary": "Optimiert Kommunikationskosten: weniger Meetings, schnellere Entscheidungen, ohne Governance/Qualität zu verlieren.\n",
      "core_decision": "Wie wird Entscheidungsfähigkeit erhöht, während Kommunikationslast sinkt?\n",
      "tags": [
        "communication",
        "operations"
      ],
      "links": [
        {
          "rel": "is_reduced_by",
          "to": "communication_channels",
          "strength": 0.6
        },
        {
          "rel": "is_reduced_by",
          "to": "quality_gates",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.4,
          "max": 0.7
        },
        "communication_intensity": {
          "min": 0.7,
          "max": 1
        },
        "automatable": {
          "min": 0.4,
          "max": 0.8
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.5,
          "max": 0.85
        }
      },
      "body": "**Leitplanken**\n- Ersetze Status-Meetings durch Artefakte + Gates + klare Ownership.\n- Entscheidungen „pullen“: Vorlagen/Checklisten reduzieren Sync-Bedarf.\n- KI kann Latenz senken (Drafts, Diffs), aber Autorität bleibt geregelt (Truth Sources).\n\n**Typische Failure-Modes**\n- Meeting-Reduktion ohne Artefakte → Chaos statt Geschwindigkeit.\n- Entscheidungen werden ausgelagert → niemand ist Owner.\n- KI erzeugt viel Text → mehr Lärm, nicht mehr Klarheit.",
      "source_file": "knowledge/nodes/meeting_load_and_latency.md"
    },
    {
      "id": "module_composition",
      "title": "Module & Composition Root",
      "kind": "concept",
      "layer": 3,
      "summary": "Legt fest, wie Module gebaut, verbunden und zur Laufzeit zusammengesetzt werden (Composition Root).\n",
      "core_decision": "Wo wird zusammengesetzt (Composition Root), und welche Abhängigkeiten dürfen Module direkt haben?\n",
      "tags": [
        "architecture",
        "structure"
      ],
      "links": [
        {
          "rel": "is_enabled_by",
          "to": "interfaces_and_contracts",
          "strength": 0.7
        },
        {
          "rel": "depends_on",
          "to": "runtime_execution_authority",
          "strength": 0.6
        },
        {
          "rel": "is_enforced_by",
          "to": "quality_gates",
          "strength": 0.7
        },
        {
          "rel": "is_informed_by",
          "to": "planning_and_work",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.5,
          "max": 0.8
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.7,
          "max": 0.95
        }
      },
      "body": "**Leitplanken**\n- Module sind austauschbar nur, wenn Abhängigkeiten *gerichtet* sind (Ports/Facades).\n- Composition Root ist der einzige Ort, der “alles kennen darf”.\n- Autonomie heißt: Modul kann isoliert getestet werden (Mock Ports).\n\n**Typische Failure-Modes**\n- “Nur kurz” direkte Imports → Facade-Regeln erodieren.\n- Composition verteilt sich → Debugging wird unmöglich.\n- Module sind nicht isoliert testbar → Qualität hängt am Gesamtbuild.",
      "source_file": "knowledge/nodes/module_composition.md"
    },
    {
      "id": "observability_design",
      "title": "Observability als Architektur",
      "kind": "concept",
      "layer": 3,
      "summary": "Entscheidet, welche Signale existieren müssen (Logs/Traces/Metriken), um Verhalten sicher zu verstehen und zu steuern.\n",
      "core_decision": "Welche Signale sind verpflichtend, damit Betrieb, Debugging und Feedback-Schleifen zuverlässig funktionieren?\n",
      "tags": [
        "architecture",
        "structure",
        "observability"
      ],
      "links": [
        {
          "rel": "observes",
          "to": "runtime_execution_authority",
          "strength": 0.6
        },
        {
          "rel": "validates",
          "to": "quality_gates",
          "strength": 0.5
        },
        {
          "rel": "feeds",
          "to": "change_control",
          "strength": 0.6
        },
        {
          "rel": "enables",
          "to": "feedback_and_learning",
          "strength": 0.6
        },
        {
          "rel": "supports",
          "to": "review_and_quality",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.6,
          "max": 0.9
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.7,
          "max": 0.95
        }
      },
      "body": "**Leitplanken**\n- Observability ist *Design*: Events/Spans/IDs sind Teil der Contracts.\n- Correlation IDs (run_id etc.) als Standard – sonst ist Traceability Zufall.\n- Signals müssen zu Entscheidungen führen können (SLOs, Alerts, Regression Checks).\n\n**Typische Failure-Modes**\n- “Wir loggen später” → Feedback-Schleife bricht.\n- Nur Logs ohne Struktur → keine Kausalität, keine Suche.\n- Dashboards ohne Ownership → niemand reagiert, alles wird “Noise”.",
      "source_file": "knowledge/nodes/observability_design.md"
    },
    {
      "id": "observation_transparency",
      "title": "Beobachtung & Transparenz",
      "kind": "star",
      "layer": 1,
      "summary": "Entscheidungen darüber, was sichtbar sein muss (Wirkung, Drift, Feedback) – strategisch und technisch.",
      "core_decision": "Was muss sichtbar sein, damit Struktur- und Regelentscheidungen überprüfbar und korrigierbar bleiben?",
      "tags": [
        "observability",
        "monitoring",
        "metrics",
        "feedback",
        "learning"
      ],
      "galaxies": [
        "main"
      ],
      "links": [
        {
          "to": "process",
          "rel": "improves",
          "strength": 0.7
        },
        {
          "to": "governance",
          "rel": "enables",
          "strength": 0.5
        },
        {
          "to": "implementation",
          "rel": "depends_on",
          "strength": 0.6
        },
        {
          "to": "structure",
          "rel": "evaluated_by",
          "strength": 0.4
        },
        {
          "to": "communication",
          "rel": "informs",
          "strength": 0.3
        }
      ],
      "planets": [
        "monitoring",
        "observability",
        "tracing",
        "logs",
        "metrics",
        "drift",
        "rework",
        "decision_latency"
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 1
        },
        "communication_intensity": {
          "min": 0.1,
          "max": 0.6
        },
        "automatable": {
          "min": 0.4,
          "max": 0.9
        },
        "stability": {
          "min": 0.3,
          "max": 0.9
        },
        "centrality": {
          "min": 0.3,
          "max": 0.8
        }
      },
      "origin": {
        "seed": true,
        "synthetic": true,
        "external": true
      },
      "body": "- Beobachtung verbindet strategische Wirkung (Drift/Rework/Entscheidungs-Latenz) mit technischer Sichtbarkeit (Logs/Traces/Metriken).\n- Transparenz steuert, wo Regeln angepasst werden müssen.\n- Ohne Beobachtung werden Regeln dogmatisch oder zufällig.",
      "source_file": "knowledge/nodes/observation_transparency.md"
    },
    {
      "id": "ownership_and_raci",
      "title": "Ownership (RACI / Verantwortungen)",
      "kind": "concept",
      "layer": 3,
      "summary": "Legt fest, wer wofür Owner ist: Services, Domains, Policies, Runbooks, Data – inkl. Eskalationspfade.\n",
      "core_decision": "Wer ist Owner für welche Entscheidungen und Artefakte – und wie wird Ownership sichtbar gemacht?\n",
      "tags": [
        "governance",
        "operations"
      ],
      "links": [
        {
          "rel": "enables",
          "to": "actionability_and_ownership",
          "strength": 0.6
        },
        {
          "rel": "supports",
          "to": "change_control",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.5,
          "max": 0.8
        },
        "automatable": {
          "min": 0.3,
          "max": 0.6
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.6,
          "max": 0.95
        }
      },
      "body": "**Leitplanken**\n- Ownership ist ein Artefakt (file, registry), nicht implizit.\n- Jede kritische Komponente hat Owner + Backup + Eskalation.\n- Ohne Owner kein Alert, kein SLO, kein Policy-Change.\n\n**Typische Failure-Modes**\n- “Alle sind zuständig” → niemand ist zuständig.\n- Ownership nur sozial → bei Wechseln geht Wissen verloren.\n- Eskalation unklar → Incidents dauern unnötig.",
      "source_file": "knowledge/nodes/ownership_and_raci.md"
    },
    {
      "id": "planning_and_work",
      "title": "Planung & Arbeitspakete",
      "kind": "concept",
      "layer": 3,
      "summary": "Schneidet Spezifikationen in kleine, überprüfbare Schritte und minimiert Risiko durch frühes Feedback.\n",
      "core_decision": "Wie wird Arbeit so geschnitten, dass Feedback früh kommt und Abhängigkeiten sichtbar bleiben?\n",
      "tags": [
        "process",
        "seed"
      ],
      "links": [
        {
          "rel": "is_decomposed_from",
          "to": "specification",
          "strength": 0.8
        },
        {
          "rel": "schedules",
          "to": "execution",
          "strength": 0.8
        },
        {
          "rel": "is_adjusted_by",
          "to": "review_and_quality",
          "strength": 0.6
        },
        {
          "rel": "respects",
          "to": "module_composition",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.8
        },
        "communication_intensity": {
          "min": 0.5,
          "max": 0.8
        },
        "automatable": {
          "min": 0.3,
          "max": 0.6
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.6,
          "max": 0.8
        }
      },
      "body": "**Leitplanken**\n- Ein Arbeitspaket ist erst „klein genug“, wenn es in <1–2 Sessions reviewbar/testbar ist.\n- Plane nach *Risiko* (Unklarheit, Abhängigkeiten), nicht nach „ist halt der nächste Schritt“.\n- Definiere pro Schritt ein konkretes „Proof“-Artefakt (Test, Demo, Signal, Diff).\n\n**Typische Failure-Modes**\n- Pakete sind „zu groß“ → Reviews werden oberflächlich, CI/Tests werden umgangen.\n- Reihenfolge ignoriert Abhängigkeiten → später teure Rework-Schleifen.\n- Kein klarer Proof → Fortschritt ist nur Aktivität, nicht Ergebnis.",
      "source_file": "knowledge/nodes/planning_and_work.md"
    },
    {
      "id": "policy_system",
      "title": "Policies & Regelwerk (Verbindlichkeit)",
      "kind": "concept",
      "layer": 3,
      "summary": "Definiert Policies als durchsetzbare Regeln: Architekturregeln, Security-Policies, Spec-Regeln, Review-Regeln.\n",
      "core_decision": "Welche Regeln sind verbindlich, und wie werden sie als Gates/Checks technisch erzwungen?\n",
      "tags": [
        "governance",
        "quality"
      ],
      "links": [
        {
          "rel": "is_enforced_by",
          "to": "quality_gates",
          "strength": 0.7
        },
        {
          "rel": "is_versioned_by",
          "to": "change_control",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.7,
          "max": 1
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.7,
          "max": 1
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.7,
          "max": 0.95
        }
      },
      "body": "**Leitplanken**\n- Policies sind kurz, testbar und als Gate ausführbar.\n- Jede Policy hat Motivation + Beispiel + “wie prüfen wir’s?”.\n- Policies leben in Git, Änderungen sind reviewpflichtig.\n\n**Typische Failure-Modes**\n- Policies als Prosa → nicht enforcebar.\n- Viele Policies ohne Priorisierung → werden ignoriert.\n- Änderungen ohne Diff/Review → Governance driftet.",
      "source_file": "knowledge/nodes/policy_system.md"
    },
    {
      "id": "problem_framing",
      "title": "Problem Framing",
      "kind": "concept",
      "layer": 3,
      "summary": "Klärt Problem, Kontext, Constraints und Erfolgskriterien so, dass Menschen und KI dieselbe Aufgabe lösen.\n",
      "core_decision": "Wie wird das Problem so gerahmt, dass Ziele, Grenzen und Erfolg/Fehlschlag operationalisierbar sind?\n",
      "tags": [
        "process",
        "seed"
      ],
      "links": [
        {
          "rel": "informs",
          "to": "requirements",
          "strength": 0.8
        },
        {
          "rel": "anchors",
          "to": "specification",
          "strength": 0.6
        },
        {
          "rel": "is_refined_by",
          "to": "feedback_and_learning",
          "strength": 0.7
        },
        {
          "rel": "implies",
          "to": "architecture_boundaries",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.6,
          "max": 0.9
        },
        "automatable": {
          "min": 0.2,
          "max": 0.4
        },
        "stability": {
          "min": 0.3,
          "max": 0.6
        },
        "centrality": {
          "min": 0.7,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Definiere *Outcome* (Wirkung) und *Scope* (Nicht-Ziele) explizit.\n- Nenne harte Constraints (Security, Legal, Budget, Timebox, Betrieb).\n- Formuliere ein „Stop-Kriterium“ (woran erkennst du, dass du *nicht* weiter optimierst).\n\n**Typische Failure-Modes**\n- „Alles ist wichtig“ → Scope explodiert, Specs werden beliebig.\n- Erfolg ist nur „gefühlt“ → später kein sauberes Review/Monitoring möglich.\n- KI optimiert auf falsche Proxy-Ziele (z.B. Code statt Outcome).",
      "source_file": "knowledge/nodes/problem_framing.md"
    },
    {
      "id": "process",
      "title": "Prozess",
      "kind": "star",
      "layer": 1,
      "summary": "Entscheidungen darüber, wie Struktur- und Regelentscheidungen entstehen, validiert und verändert werden.",
      "core_decision": "Wie organisieren wir Entstehung, Validierung und Änderung von Struktur- und Regelentscheidungen?",
      "tags": [
        "workflow",
        "iteration",
        "handoffs",
        "decision_loop"
      ],
      "galaxies": [
        "main",
        "process_galaxy"
      ],
      "links": [
        {
          "to": "communication",
          "rel": "depends_on",
          "strength": 0.7
        },
        {
          "to": "governance",
          "rel": "constrained_by",
          "strength": 0.6
        },
        {
          "to": "implementation",
          "rel": "realized_by",
          "strength": 0.5
        },
        {
          "to": "observation_transparency",
          "rel": "evaluated_by",
          "strength": 0.7
        },
        {
          "to": "structure",
          "rel": "coevolves_with",
          "strength": 0.6
        }
      ],
      "planets": [
        "handoffs",
        "decision_points",
        "iteration",
        "review_mechanics",
        "spec_loop",
        "change_management"
      ],
      "gradients": {
        "explicitness": {
          "min": 0.3,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.9
        },
        "automatable": {
          "min": 0.2,
          "max": 0.8
        },
        "stability": {
          "min": 0.2,
          "max": 0.8
        },
        "centrality": {
          "min": 0.4,
          "max": 0.9
        }
      },
      "origin": {
        "seed": true,
        "synthetic": true,
        "external": true
      },
      "body": "- Prozess ist die Architektur der Feedbackzyklen: wo wird entschieden, wo validiert, wo gelernt?\n- Agil/Wasserfall ist hier Strukturfrage: linear vs. iterativ, spätes vs. frühes Feedback.\n- KI senkt Ausführungskosten und verschiebt Engpässe zu Entscheidung & Validierung.",
      "source_file": "knowledge/nodes/process.md"
    },
    {
      "id": "quality_gates",
      "title": "Quality Gates & Policies",
      "kind": "concept",
      "layer": 3,
      "summary": "Formale Checks (Lint, Tests, Contract/Schema-Gates), die Architektur- und Prozessregeln automatisch durchsetzen.\n",
      "core_decision": "Welche Gates sind nicht verhandelbar – und welche werden als Empfehlungen geführt?\n",
      "tags": [
        "architecture",
        "process",
        "quality"
      ],
      "links": [
        {
          "rel": "enforces",
          "to": "architecture_boundaries",
          "strength": 0.7
        },
        {
          "rel": "enforces",
          "to": "interfaces_and_contracts",
          "strength": 0.7
        },
        {
          "rel": "enforces",
          "to": "module_composition",
          "strength": 0.7
        },
        {
          "rel": "supports",
          "to": "change_control",
          "strength": 0.6
        },
        {
          "rel": "reinforces",
          "to": "review_and_quality",
          "strength": 0.7
        },
        {
          "rel": "reduces",
          "to": "meeting_load_and_latency",
          "strength": 0.4
        },
        {
          "rel": "uses",
          "to": "signals_and_slos",
          "strength": 0.4
        },
        {
          "rel": "enforces",
          "to": "supply_chain_security",
          "strength": 0.5
        },
        {
          "rel": "is_implemented_by",
          "to": "automation_and_scripts",
          "strength": 0.5
        },
        {
          "rel": "enforces",
          "to": "policy_system",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.2,
          "max": 0.5
        },
        "automatable": {
          "min": 0.8,
          "max": 1
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.7,
          "max": 0.95
        }
      },
      "body": "**Leitplanken**\n- Gates codieren Regeln: “kein Review-Gefühl, sondern messbar”.\n- Reihenfolge: billig → teuer (Format/Lint → Unit → Contract → Smoke).\n- Fail-Fast mit klaren Meldungen und Fix-Hinweisen.\n\n**Typische Failure-Modes**\n- Gates sind optional → Regression wird Normalzustand.\n- Gates ohne Developer-UX → werden umgangen.\n- Zu viele Gates ohne Priorisierung → alles wird langsam und ignoriert.",
      "source_file": "knowledge/nodes/quality_gates.md"
    },
    {
      "id": "reproducible_builds",
      "title": "Reproduzierbare Builds & Toolchain Pinning",
      "kind": "concept",
      "layer": 3,
      "summary": "Macht Builds deterministisch: Versionen pinnen, Lockfiles, definierte Toolchains, gleiche Inputs → gleiche Outputs.\n",
      "core_decision": "Welche Inputs/Versionen müssen gepinnt sein, damit Builds und Tests reproduzierbar sind?\n",
      "tags": [
        "tooling",
        "build"
      ],
      "links": [
        {
          "rel": "is_enforced_by",
          "to": "quality_gates",
          "strength": 0.6
        },
        {
          "rel": "reduces",
          "to": "supply_chain_security",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.2,
          "max": 0.5
        },
        "automatable": {
          "min": 0.7,
          "max": 1
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Toolchain/Deps pinnen (Lockfiles, versions, env).\n- Rebuilds müssen gleich sein (oder Abweichung erklärbar).\n- Updates sind bewusst: changelog + tests + rollback story.\n\n**Typische Failure-Modes**\n- “latest” überall → random breakage.\n- Keine Lockfiles → transitive Überraschungen.\n- Builds nicht replaybar → Debugging wird Spekulation.",
      "source_file": "knowledge/nodes/reproducible_builds.md"
    },
    {
      "id": "requirements",
      "title": "Anforderungen",
      "kind": "concept",
      "layer": 3,
      "summary": "Erfasst, priorisiert und versioniert Anforderungen (funktional + nicht-funktional) inklusive Trade-offs.\n",
      "core_decision": "Welche Anforderungen sind verbindlich, welche verhandelbar – und wie werden Änderungen kontrolliert?\n",
      "tags": [
        "process",
        "seed"
      ],
      "links": [
        {
          "rel": "is_informed_by",
          "to": "problem_framing",
          "strength": 0.8
        },
        {
          "rel": "constrains",
          "to": "specification",
          "strength": 0.9
        },
        {
          "rel": "shapes",
          "to": "planning_and_work",
          "strength": 0.7
        },
        {
          "rel": "shapes",
          "to": "interfaces_and_contracts",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.6,
          "max": 0.9
        },
        "automatable": {
          "min": 0.3,
          "max": 0.5
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.7,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Trenne: *Must / Should / Could / Won’t* (oder ähnlich) – sonst gibt’s keine Steuerung.\n- Nicht-Funktionales ist erst „real“, wenn es test-/beobachtbar wird (SLOs, Limits, Policies).\n- Versioniere Anforderungen wie Code: diffbar, reviewbar, rückrollbar.\n\n**Typische Failure-Modes**\n- Requirements werden als „Ticket-Text“ behandelt → keine Invarianten, keine Tests.\n- NFRs werden vergessen → Betrieb/Observability fällt hinten runter.\n- Keine Change-Control → Spezifikation driftet unbemerkt.",
      "source_file": "knowledge/nodes/requirements.md"
    },
    {
      "id": "review_and_quality",
      "title": "Review & Qualität",
      "kind": "concept",
      "layer": 3,
      "summary": "Review ist ein Gate: Specs, Code, Tests und Risiken werden gegen explizite Regeln geprüft.\n",
      "core_decision": "Was wird geprüft, nach welchen Regeln – und wie verhindert man Regressions systematisch statt ritualisiert?\n",
      "tags": [
        "process",
        "seed"
      ],
      "links": [
        {
          "rel": "consumes",
          "to": "execution",
          "strength": 0.9
        },
        {
          "rel": "validates",
          "to": "specification",
          "strength": 0.7
        },
        {
          "rel": "yields",
          "to": "feedback_and_learning",
          "strength": 0.7
        },
        {
          "rel": "is_supported_by",
          "to": "quality_gates",
          "strength": 0.7
        },
        {
          "rel": "requires",
          "to": "observability_design",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.5,
          "max": 0.8
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.7,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Reviews folgen einer Checkliste, die aus Specs/Policies kommt (nicht aus Geschmack).\n- Qualität ist „Shift-left“: Gates so früh wie möglich (Lint → Unit → Contract → Smoke).\n- Review muss *Risiko* adressieren: was könnte brechen, wie merken wir es?\n\n**Typische Failure-Modes**\n- Review als Stil-Debatte → Regeln fehlen, Ergebnis ist inkonsistent.\n- Tests sind optional → Regression wird zur Normalität.\n- Kein Gate gegen Spec-Drift → Code ändert Verhalten ohne Spec-Update.",
      "source_file": "knowledge/nodes/review_and_quality.md"
    },
    {
      "id": "risk_and_compliance",
      "title": "Risiko, Compliance & Ausnahmeprozesse",
      "kind": "concept",
      "layer": 3,
      "summary": "Behandelt Risiken als Entscheidungen: akzeptieren, mitigieren, transferieren – inkl. Ausnahmen (mit Audit).\n",
      "core_decision": "Wie werden Risiken und Ausnahmen sichtbar, auditierbar und zeitlich begrenzt gehandhabt?\n",
      "tags": [
        "governance",
        "security"
      ],
      "links": [
        {
          "rel": "aligns_with",
          "to": "threat_modeling",
          "strength": 0.5
        },
        {
          "rel": "constrains",
          "to": "least_privilege_and_access",
          "strength": 0.4
        },
        {
          "rel": "is_informed_by",
          "to": "security_incidents",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.5,
          "max": 0.8
        },
        "automatable": {
          "min": 0.3,
          "max": 0.6
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Ausnahmen sind timeboxed + owner + rationale + rollback plan.\n- Risikoentscheidungen verlinken auf Mitigations (Policy/Gate/Runbook).\n- Compliance ist “by default” über Policies/Gates, nicht per Nacharbeit.\n\n**Typische Failure-Modes**\n- Ausnahmen werden dauerhaft → Regeln erodieren.\n- Risiko wird nur gefühlt → keine Priorisierung.\n- Compliance als Papier → reale Systeme weichen ab.",
      "source_file": "knowledge/nodes/risk_and_compliance.md"
    },
    {
      "id": "runbooks_and_playbooks",
      "title": "Runbooks & Playbooks",
      "kind": "concept",
      "layer": 3,
      "summary": "Macht Reaktion reproduzierbar: standardisierte Diagnose- und Handlungsabläufe, die aus Signalen zu konkreten Aktionen führen.\n",
      "core_decision": "Welche Runbooks sind verpflichtend, und wie bleiben sie aktuell (statt zu veralten)?\n",
      "tags": [
        "observability",
        "operations"
      ],
      "links": [
        {
          "rel": "is_required_by",
          "to": "actionability_and_ownership",
          "strength": 0.6
        },
        {
          "rel": "supports",
          "to": "incidents_and_postmortems",
          "strength": 0.6
        },
        {
          "rel": "is_supported_by",
          "to": "dashboards_and_queries",
          "strength": 0.6
        },
        {
          "rel": "uses",
          "to": "signals_and_slos",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Runbook = „wenn Signal X, dann mache Y“ (inkl. Query/Command/Check).\n- Versioniere Runbooks wie Code, verlinke sie an Signals/Services/Owners.\n- Pflege über Ereignisse: jedes Incident aktualisiert Runbooks oder erzeugt neue.\n\n**Typische Failure-Modes**\n- Runbooks veralten → im Incident wertlos.\n- Nur „Wiki-Text“ ohne Commands/Queries → nicht ausführbar.\n- Kein Ownership → niemand pflegt, niemand vertraut.",
      "source_file": "knowledge/nodes/runbooks_and_playbooks.md"
    },
    {
      "id": "runtime_execution_authority",
      "title": "Runtime & Execution Authority",
      "kind": "concept",
      "layer": 3,
      "summary": "Definiert, wer Workflows ausführt, Zustände kontrolliert und deterministische Ausführung ermöglicht.\n",
      "core_decision": "Wer ist die Ausführungsinstanz (Execution Authority), und wie wird deterministisches Verhalten sichergestellt?\n",
      "tags": [
        "architecture",
        "structure"
      ],
      "links": [
        {
          "rel": "is_enabled_by",
          "to": "module_composition",
          "strength": 0.6
        },
        {
          "rel": "requires",
          "to": "observability_design",
          "strength": 0.6
        },
        {
          "rel": "is_covered_by",
          "to": "quality_gates",
          "strength": 0.6
        },
        {
          "rel": "governs",
          "to": "execution",
          "strength": 0.6
        },
        {
          "rel": "is_constrained_by",
          "to": "sandboxing_and_isolation",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.6,
          "max": 0.9
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.7,
          "max": 0.95
        }
      },
      "body": "**Leitplanken**\n- Eine klare Ausführungsautorität reduziert “heimliche Nebenläufe” und Race-Conditions.\n- Determinismus: Inputs/Configs/Versions sind Teil des Runs (replaybar).\n- Side-effects (IO) über Ports und eindeutig identifizierbar.\n\n**Typische Failure-Modes**\n- Mehrere “kleine Runner” → Zustandsdrift, schwer reproduzierbar.\n- Side-effects ohne Tracking → Bugs nicht replaybar.\n- Implizite globale Zustände → Testbarkeit bricht.",
      "source_file": "knowledge/nodes/runtime_execution_authority.md"
    },
    {
      "id": "sandboxing_and_isolation",
      "title": "Sandboxing & Isolation",
      "kind": "concept",
      "layer": 3,
      "summary": "Trennt riskante Ausführung (Code, Tools, Imports) in isolierte Umgebungen mit klaren Grenzen und minimalen Rechten.\n",
      "core_decision": "Welche Ausführungen müssen isoliert sein, und welche Limits (FS/Netz/CPU) sind verpflichtend?\n",
      "tags": [
        "security",
        "architecture"
      ],
      "links": [
        {
          "rel": "constrains",
          "to": "runtime_execution_authority",
          "strength": 0.5
        },
        {
          "rel": "reduces",
          "to": "supply_chain_security",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.2,
          "max": 0.5
        },
        "automatable": {
          "min": 0.6,
          "max": 0.9
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Default: deny (Netz/FS/Secrets) – explizite Allowlists.\n- Reproduzierbare Sandbox-Profile (limits, mounts, network policy).\n- Alles, was KI „ausführt“, läuft nicht in der gleichen Trust-Zone wie Produktivsysteme.\n\n**Typische Failure-Modes**\n- „Nur lokal“ ohne Isolation → später wird es produktiv und gefährlich.\n- Zu offene Netze/Volumes → Datenabfluss.\n- Keine Limits → DoS durch unbounded tasks.",
      "source_file": "knowledge/nodes/sandboxing_and_isolation.md"
    },
    {
      "id": "secrets_and_passwords",
      "title": "Secrets & Passwort-Management (z.B. KeePass)",
      "kind": "concept",
      "layer": 3,
      "summary": "Regelt, wie Secrets erzeugt, gespeichert, geteilt, rotiert und auditierbar verwendet werden – ohne Leaks.\n",
      "core_decision": "Wo liegen Secrets, wer darf sie nutzen, und wie wird Leak-Risiko technisch minimiert?\n",
      "tags": [
        "security",
        "operations"
      ],
      "links": [
        {
          "rel": "requires",
          "to": "least_privilege_and_access",
          "strength": 0.6
        },
        {
          "rel": "is_guarded_by",
          "to": "quality_gates",
          "strength": 0.5
        },
        {
          "rel": "is_applied_in",
          "to": "dev_secrets_and_env",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.5,
          "max": 0.8
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Keine Secrets in Repo/Chat/Logs. Punkt.\n- Zugriff über Rollen/Policies; Rotation/Revocation ist geplant, nicht ad-hoc.\n- Shared Secrets sind minimiert; “break glass” ist auditierbar.\n\n**Typische Failure-Modes**\n- KeePass/Secrets als „Team-Notiz“ → kein Audit, kein Prinzip.\n- Rotation nie gemacht → Zeitbombe.\n- Leaks durch Debug-Logs/Stacktraces → sofortiger Impact.",
      "source_file": "knowledge/nodes/secrets_and_passwords.md"
    },
    {
      "id": "security_incidents",
      "title": "Security Incidents & Response",
      "kind": "concept",
      "layer": 3,
      "summary": "Definiert Reaktion auf Security-Vorfälle: Detection, Containment, Rotation, Kommunikation, Postmortem, Learnings.\n",
      "core_decision": "Wie reagieren wir auf Security-Vorfälle schnell und kontrolliert – inklusive Rotation/Revocation und Lessons Learned?\n",
      "tags": [
        "security",
        "operations"
      ],
      "links": [
        {
          "rel": "depends_on",
          "to": "signals_and_slos",
          "strength": 0.4
        },
        {
          "rel": "depends_on",
          "to": "actionability_and_ownership",
          "strength": 0.5
        },
        {
          "rel": "uses",
          "to": "runbooks_and_playbooks",
          "strength": 0.5
        },
        {
          "rel": "produces",
          "to": "change_control",
          "strength": 0.5
        },
        {
          "rel": "updates",
          "to": "risk_and_compliance",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.6,
          "max": 0.9
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.4,
          "max": 0.7
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Detection → Containment → Rotation/Revocation → Recovery → Postmortem.\n- Security-Incidents haben eigene Playbooks (nicht nur „normaler Incident“).\n- Kommunikation ist geregelt (need-to-know, audit, compliance).\n\n**Typische Failure-Modes**\n- Kein Rotation-Plan → Keys bleiben kompromittiert.\n- Zu spät eskaliert → Blast radius wächst.\n- Learnings nicht in Policies/Gates → Wiederholung.",
      "source_file": "knowledge/nodes/security_incidents.md"
    },
    {
      "id": "security_safety",
      "title": "Security & Safety",
      "kind": "core",
      "layer": 2,
      "summary": "Security/Safety sind Systementscheidungen: Secrets, Isolation, Zugriff, Supply Chain und Datenschutz – erzwingbar, nicht optional.\n",
      "core_decision": "Welche Sicherheitsregeln sind nicht verhandelbar – und wie werden sie durch Prozesse, Policies und Gates automatisch durchgesetzt?\n",
      "tags": [
        "core",
        "security"
      ],
      "links": [
        {
          "rel": "expands_to",
          "to": "secrets_and_passwords",
          "strength": 0.6
        },
        {
          "rel": "expands_to",
          "to": "sandboxing_and_isolation",
          "strength": 0.6
        },
        {
          "rel": "expands_to",
          "to": "least_privilege_and_access",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.5,
          "max": 0.85
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.7,
          "max": 1
        }
      },
      "body": "**Leitplanken**\n- Security ist „by design“: Defaults, Policies, Gates – nicht nachträgliches Review.\n- Secrets/PII dürfen nie „aus Versehen“ in Logs/Repos landen (Scrubbing/Allowlists).\n- Isolation (Sandbox) ist Pflicht für Code-Ausführung und riskante Tools.\n\n**Typische Failure-Modes**\n- Security wird als Checkliste behandelt → driftet und wird umgangen.\n- Secrets in Env/Logs/Chat → sofortiger Schaden.\n- Keine Ownership/Automatisierung → Regeln sind nur Wunschdenken.",
      "source_file": "knowledge/nodes/security_safety.md"
    },
    {
      "id": "shared_language_and_models",
      "title": "Gemeinsame Sprache & Modelle",
      "kind": "concept",
      "layer": 3,
      "summary": "Stellt sicher, dass Begriffe, Domänenmodelle und Metaphern konsistent sind – sonst reden KI und Menschen aneinander vorbei.\n",
      "core_decision": "Welche Begriffe/Modelle sind verbindlich, und wie wird ihre Bedeutung stabil gehalten?\n",
      "tags": [
        "communication"
      ],
      "links": [
        {
          "rel": "enables",
          "to": "artifacts_and_truth_sources",
          "strength": 0.6
        },
        {
          "rel": "reduces",
          "to": "ambiguity_and_alignment",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.5,
          "max": 0.8
        },
        "automatable": {
          "min": 0.2,
          "max": 0.5
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Definiere zentrale Begriffe (Glossar/Domain Model) als Artefakte mit Git-History.\n- Beispiele > Definitionen: „So sieht’s aus“ reduziert Interpretationsspielraum.\n- KI sollte Begriffe *verwenden*, nicht neu erfinden (Policy/Contracts).\n\n**Typische Failure-Modes**\n- Begriffssalat → jeder meint was anderes, Specs werden unbrauchbar.\n- Modelle nur in Köpfen → Onboarding und KI-Assists scheitern.\n- Lokale Dialekte je Modul → Integration eskaliert.",
      "source_file": "knowledge/nodes/shared_language_and_models.md"
    },
    {
      "id": "signals_and_slos",
      "title": "Signale & SLOs",
      "kind": "concept",
      "layer": 3,
      "summary": "Definiert, welche Signale den Systemzustand beweisen (SLOs/SLIs) und wie „gesund/kaputt“ entschieden wird.\n",
      "core_decision": "Welche SLOs/Signale sind zwingend, um Verhalten zu beurteilen und Prioritäten zu steuern?\n",
      "tags": [
        "observability",
        "operations"
      ],
      "links": [
        {
          "rel": "informs",
          "to": "feedback_and_learning",
          "strength": 0.6
        },
        {
          "rel": "feeds",
          "to": "quality_gates",
          "strength": 0.5
        },
        {
          "rel": "drives",
          "to": "quality_gates",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.5,
          "max": 0.8
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Wenige, harte Signale > viele Metriken (SLOs als Entscheidungsgrundlage).\n- SLOs müssen *operationalisierbar* sein (Messung + Schwelle + Konsequenz).\n- “Error budget” oder ähnliches: Qualität wird planbar steuerbar.\n\n**Typische Failure-Modes**\n- Keine SLOs → Priorisierung wird politisch.\n- Metriken ohne Entscheidung → Dashboard-Friedhof.\n- Schwellen willkürlich → Alerts werden ignoriert.",
      "source_file": "knowledge/nodes/signals_and_slos.md"
    },
    {
      "id": "specification",
      "title": "Spezifikation",
      "kind": "concept",
      "layer": 3,
      "summary": "Macht Verhalten, Invarianten, Schnittstellen und Tests explizit – Specs sind die führende Wahrheit.\n",
      "core_decision": "Was muss explizit sein, damit Implementierung nicht zur Spekulation wird und Änderungen kontrollierbar bleiben?\n",
      "tags": [
        "process",
        "seed"
      ],
      "links": [
        {
          "rel": "is_constrained_by",
          "to": "requirements",
          "strength": 0.9
        },
        {
          "rel": "decomposes_into",
          "to": "planning_and_work",
          "strength": 0.8
        },
        {
          "rel": "is_validated_by",
          "to": "review_and_quality",
          "strength": 0.7
        },
        {
          "rel": "is_controlled_by",
          "to": "change_control",
          "strength": 0.7
        },
        {
          "rel": "includes",
          "to": "interfaces_and_contracts",
          "strength": 0.6
        },
        {
          "rel": "is_a_truth_source_for",
          "to": "artifacts_and_truth_sources",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.7,
          "max": 1
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.8,
          "max": 1
        }
      },
      "body": "**Leitplanken**\n- Definiere Invarianten (was *immer* gelten muss) und Boundaries (was *nicht* gemacht wird).\n- Jede Spez-Aussage braucht eine Validierung (Unit/Smoke/Contract/Observability-Signal).\n- Specs sollen kompakt sein: Regeln > Erklärtexte.\n\n**Typische Failure-Modes**\n- Spec = „Prosa“ ohne Testbarkeit → Implementierung übernimmt die Deutungshoheit.\n- Zu detailreich (Mikro-Design) → Specs werden schnell veraltet und ignoriert.\n- Änderungen passieren nur im Code → Drift und Review wird blind.",
      "source_file": "knowledge/nodes/specification.md"
    },
    {
      "id": "structure",
      "title": "Struktur",
      "kind": "star",
      "layer": 1,
      "summary": "Entscheidungen über Grenzen, Verantwortlichkeiten und Abhängigkeiten.",
      "core_decision": "Wie schneiden wir Verantwortlichkeiten, Grenzen und Abhängigkeiten so, dass Veränderung kontrollierbar bleibt?",
      "tags": [
        "architecture",
        "boundaries",
        "ownership",
        "dependency"
      ],
      "galaxies": [
        "main"
      ],
      "links": [
        {
          "to": "process",
          "rel": "coevolves_with",
          "strength": 0.6
        },
        {
          "to": "governance",
          "rel": "constrained_by",
          "strength": 0.6
        },
        {
          "to": "implementation",
          "rel": "realized_by",
          "strength": 0.7
        },
        {
          "to": "observation_transparency",
          "rel": "evaluated_by",
          "strength": 0.4
        },
        {
          "to": "communication",
          "rel": "depends_on",
          "strength": 0.5
        }
      ],
      "planets": [
        "boundaries",
        "interfaces",
        "invariants",
        "dependency_rules",
        "adr"
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.95
        },
        "communication_intensity": {
          "min": 0.2,
          "max": 0.7
        },
        "automatable": {
          "min": 0.1,
          "max": 0.4
        },
        "stability": {
          "min": 0.5,
          "max": 0.95
        },
        "centrality": {
          "min": 0.6,
          "max": 0.95
        }
      },
      "origin": {
        "seed": true,
        "synthetic": true,
        "external": true
      },
      "body": "- Struktur ist nicht nur Codeform: sie ist Verantwortungs- und Veränderungsarchitektur.\n- Gute Struktur reduziert Kopplung und macht Regeln/Gates präziser.\n- Strukturentscheidungen sind langlebig, aber bewusst evolvierbar.",
      "source_file": "knowledge/nodes/structure.md"
    },
    {
      "id": "supply_chain_security",
      "title": "Supply-Chain Security",
      "kind": "concept",
      "layer": 3,
      "summary": "Schützt Abhängigkeiten und Build-Pipeline: Pinning, Signaturen, SBOM, Scans, Repro-Builds.\n",
      "core_decision": "Wie wird verhindert, dass Dependencies/Build-Pipeline zur Angriffsfläche werden?\n",
      "tags": [
        "security",
        "build"
      ],
      "links": [
        {
          "rel": "is_enforced_by",
          "to": "quality_gates",
          "strength": 0.6
        },
        {
          "rel": "constrains",
          "to": "module_composition",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.2,
          "max": 0.5
        },
        "automatable": {
          "min": 0.7,
          "max": 1
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Pinning/Lockfiles sind Pflicht; Updates sind bewusst und reviewbar.\n- SBOM + Signaturen, wo möglich; Scans als Gate.\n- Reproduzierbare Builds reduzieren „works on my machine“-Risiko.\n\n**Typische Failure-Modes**\n- Wild-west Updates → unerklärliche Brüche/Backdoors.\n- Scans ohne Konsequenz → “rot ist normal”.\n- Unpinned transitive deps → unsichtbare Angriffsfläche.",
      "source_file": "knowledge/nodes/supply_chain_security.md"
    },
    {
      "id": "telemetry_design",
      "title": "Telemetrie-Design (Logs/Traces/Metriken)",
      "kind": "concept",
      "layer": 3,
      "summary": "Entscheidet, welche Events/Spans/IDs existieren und wie Korrelation (run_id etc.) garantiert wird.\n",
      "core_decision": "Welche Telemetrie ist verpflichtend, damit Kausalität und Debugging zuverlässig sind?\n",
      "tags": [
        "observability",
        "architecture"
      ],
      "links": [
        {
          "rel": "is_part_of",
          "to": "observability_design",
          "strength": 0.7
        },
        {
          "rel": "supports",
          "to": "runtime_execution_authority",
          "strength": 0.5
        },
        {
          "rel": "enables",
          "to": "feedback_and_learning",
          "strength": 0.5
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.6,
          "max": 0.9
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Korrelation ist Pflicht: run_id / request_id / entity_id als Standard.\n- Strukturierte Logs und stabile Event-Namen (sonst keine Queries).\n- Traces sind „Prozess-Sicht“, Logs sind „Detail-Sicht“ – beide bewusst designen.\n\n**Typische Failure-Modes**\n- Unstrukturierte Logs → keine Suche, keine Aggregation.\n- IDs fehlen → keine Kausalität, nur Vermutungen.\n- Telemetrie nur lokal → Betrieb ist blind.",
      "source_file": "knowledge/nodes/telemetry_design.md"
    },
    {
      "id": "threat_modeling",
      "title": "Threat Modeling & Risk Decisions",
      "kind": "concept",
      "layer": 3,
      "summary": "Macht Angriffsflächen und Risiken explizit und koppelt sie an konkrete Gegenmaßnahmen, Policies und Gates.\n",
      "core_decision": "Welche Risiken akzeptieren wir bewusst – und welche müssen technisch verhindert werden?\n",
      "tags": [
        "security",
        "architecture"
      ],
      "links": [
        {
          "rel": "informs",
          "to": "architecture_boundaries",
          "strength": 0.5
        },
        {
          "rel": "informs",
          "to": "quality_gates",
          "strength": 0.5
        },
        {
          "rel": "triggers",
          "to": "decision_records",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.5,
          "max": 0.85
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.3,
          "max": 0.6
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.6,
          "max": 0.9
        }
      },
      "body": "**Leitplanken**\n- Risiken werden als Entscheidungen behandelt (mit Owner, Kontext, Mitigation).\n- Threat Model ist updatebar: nach Incidents und großen Architekturänderungen.\n- Fokus auf größte Angriffsflächen (Blast radius, secrets, supply chain).\n\n**Typische Failure-Modes**\n- Threat model als einmaliges PDF → veraltet sofort.\n- Nur hypothetisch, keine Maßnahmen → Theater.\n- Risiken werden „implizit akzeptiert“ → später Überraschungen.",
      "source_file": "knowledge/nodes/threat_modeling.md"
    },
    {
      "id": "tooling_dev_environment",
      "title": "Tooling & Dev-Environment",
      "kind": "core",
      "layer": 2,
      "summary": "Das Dev-Environment ist ein Betriebssystem: Toolchain, Reproduzierbarkeit, Automatisierung und sichere Ausführung.\n",
      "core_decision": "Welche Tools/Standards sind verbindlich, damit Entwicklung schnell, reproduzierbar und sicher bleibt – auch mit KI?\n",
      "tags": [
        "core",
        "tooling"
      ],
      "links": [
        {
          "rel": "expands_to",
          "to": "local_dev_environment",
          "strength": 0.6
        },
        {
          "rel": "expands_to",
          "to": "automation_and_scripts",
          "strength": 0.6
        },
        {
          "rel": "expands_to",
          "to": "ai_assisted_workflow",
          "strength": 0.6
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.3,
          "max": 0.6
        },
        "automatable": {
          "min": 0.6,
          "max": 0.9
        },
        "stability": {
          "min": 0.5,
          "max": 0.8
        },
        "centrality": {
          "min": 0.7,
          "max": 1
        }
      },
      "body": "**Leitplanken**\n- Tooling ist Teil der Architektur: es steuert Qualität, Geschwindigkeit und Sicherheit.\n- Reproduzierbarkeit > “läuft bei mir”.\n- KI-Tools brauchen klare Grenzen (Sandbox, Truth Sources, Gates).\n\n**Typische Failure-Modes**\n- Tooling driftet pro Person → Debugging/Onboarding eskaliert.\n- Keine Gates → Qualität wird Zufall.\n- KI kann alles ausführen → Sicherheitsrisiko.",
      "source_file": "knowledge/nodes/tooling_dev_environment.md"
    },
    {
      "id": "transparency_and_access",
      "title": "Transparenz, Zugriff & Datenschutz",
      "kind": "concept",
      "layer": 3,
      "summary": "Regelt, wer welche Telemetrie sehen darf, wie PII/Security gehandhabt werden, und wie Audit/Compliance passt.\n",
      "core_decision": "Wie wird Transparenz maximiert, ohne Security/Privacy zu verletzen?\n",
      "tags": [
        "observability",
        "security",
        "governance"
      ],
      "links": [
        {
          "rel": "constrains",
          "to": "telemetry_design",
          "strength": 0.5
        },
        {
          "rel": "is_part_of",
          "to": "change_control",
          "strength": 0.4
        },
        {
          "rel": "constrains",
          "to": "artifacts_and_truth_sources",
          "strength": 0.3
        },
        {
          "rel": "requires",
          "to": "data_handling_and_privacy",
          "strength": 0.5
        },
        {
          "rel": "supports",
          "to": "auditability_and_traceability",
          "strength": 0.4
        }
      ],
      "gradients": {
        "explicitness": {
          "min": 0.6,
          "max": 0.9
        },
        "communication_intensity": {
          "min": 0.4,
          "max": 0.7
        },
        "automatable": {
          "min": 0.4,
          "max": 0.7
        },
        "stability": {
          "min": 0.6,
          "max": 0.9
        },
        "centrality": {
          "min": 0.5,
          "max": 0.85
        }
      },
      "body": "**Leitplanken**\n- Zugriff ist policy-basiert (Least Privilege) und auditierbar.\n- PII/Secrets niemals „aus Versehen“ loggen (Scrubbing/Allowlists).\n- Transparenzregeln sind Teil der Architektur-Policies.\n\n**Typische Failure-Modes**\n- Telemetrie leakt Daten → Security/Legal-Impact.\n- Zu restriktiv → niemand kann debuggen.\n- Keine Auditability → Governance bricht.",
      "source_file": "knowledge/nodes/transparency_and_access.md"
    }
  ],
  "edges": [
    {
      "from": "actionability_and_ownership",
      "to": "dashboards_and_queries",
      "rel": "requires",
      "strength": 0.5
    },
    {
      "from": "actionability_and_ownership",
      "to": "change_control",
      "rel": "drives",
      "strength": 0.5
    },
    {
      "from": "actionability_and_ownership",
      "to": "incidents_and_postmortems",
      "rel": "triggers",
      "strength": 0.6
    },
    {
      "from": "actionability_and_ownership",
      "to": "runbooks_and_playbooks",
      "rel": "requires",
      "strength": 0.6
    },
    {
      "from": "ai_assisted_workflow",
      "to": "artifacts_and_truth_sources",
      "rel": "requires",
      "strength": 0.5
    },
    {
      "from": "ai_assisted_workflow",
      "to": "sandboxing_and_isolation",
      "rel": "requires",
      "strength": 0.5
    },
    {
      "from": "ai_assisted_workflow",
      "to": "quality_gates",
      "rel": "is_guarded_by",
      "strength": 0.5
    },
    {
      "from": "ai_assisted_workflow",
      "to": "artifacts_and_truth_sources",
      "rel": "depends_on",
      "strength": 0.6
    },
    {
      "from": "ambiguity_and_alignment",
      "to": "shared_language_and_models",
      "rel": "is_reduced_by",
      "strength": 0.6
    },
    {
      "from": "ambiguity_and_alignment",
      "to": "decision_records",
      "rel": "triggers",
      "strength": 0.5
    },
    {
      "from": "ambiguity_and_alignment",
      "to": "planning_and_work",
      "rel": "shapes",
      "strength": 0.5
    },
    {
      "from": "architecture_boundaries",
      "to": "interfaces_and_contracts",
      "rel": "constrains",
      "strength": 0.8
    },
    {
      "from": "architecture_boundaries",
      "to": "change_control",
      "rel": "constrains",
      "strength": 0.7
    },
    {
      "from": "architecture_boundaries",
      "to": "observability_design",
      "rel": "is_observed_by",
      "strength": 0.5
    },
    {
      "from": "architecture_boundaries",
      "to": "problem_framing",
      "rel": "is_informed_by",
      "strength": 0.5
    },
    {
      "from": "artifacts_and_truth_sources",
      "to": "specification",
      "rel": "is_expressed_in",
      "strength": 0.6
    },
    {
      "from": "artifacts_and_truth_sources",
      "to": "decision_records",
      "rel": "is_referenced_by",
      "strength": 0.6
    },
    {
      "from": "artifacts_and_truth_sources",
      "to": "communication_channels",
      "rel": "is_guarded_by",
      "strength": 0.5
    },
    {
      "from": "artifacts_and_truth_sources",
      "to": "specification",
      "rel": "is_realized_by",
      "strength": 0.6
    },
    {
      "from": "artifacts_and_truth_sources",
      "to": "transparency_and_access",
      "rel": "requires",
      "strength": 0.3
    },
    {
      "from": "artifacts_and_truth_sources",
      "to": "ai_assisted_workflow",
      "rel": "constrains",
      "strength": 0.4
    },
    {
      "from": "auditability_and_traceability",
      "to": "telemetry_design",
      "rel": "depends_on",
      "strength": 0.4
    },
    {
      "from": "auditability_and_traceability",
      "to": "artifacts_and_truth_sources",
      "rel": "depends_on",
      "strength": 0.6
    },
    {
      "from": "auditability_and_traceability",
      "to": "transparency_and_access",
      "rel": "requires",
      "strength": 0.4
    },
    {
      "from": "automation_and_scripts",
      "to": "quality_gates",
      "rel": "implements",
      "strength": 0.6
    },
    {
      "from": "automation_and_scripts",
      "to": "planning_and_work",
      "rel": "supports",
      "strength": 0.4
    },
    {
      "from": "change_control",
      "to": "architecture_boundaries",
      "rel": "is_constrained_by",
      "strength": 0.7
    },
    {
      "from": "change_control",
      "to": "quality_gates",
      "rel": "is_supported_by",
      "strength": 0.6
    },
    {
      "from": "change_control",
      "to": "observability_design",
      "rel": "is_informed_by",
      "strength": 0.6
    },
    {
      "from": "change_control",
      "to": "specification",
      "rel": "controls",
      "strength": 0.7
    },
    {
      "from": "change_control",
      "to": "feedback_and_learning",
      "rel": "is_informed_by",
      "strength": 0.6
    },
    {
      "from": "change_control",
      "to": "decision_records",
      "rel": "is_documented_by",
      "strength": 0.5
    },
    {
      "from": "communication",
      "to": "process",
      "rel": "enables",
      "strength": 0.7
    },
    {
      "from": "communication",
      "to": "structure",
      "rel": "informs",
      "strength": 0.5
    },
    {
      "from": "communication",
      "to": "governance",
      "rel": "required_by",
      "strength": 0.4
    },
    {
      "from": "communication",
      "to": "implementation",
      "rel": "reduced_by",
      "strength": 0.4
    },
    {
      "from": "communication",
      "to": "observation_transparency",
      "rel": "guided_by",
      "strength": 0.3
    },
    {
      "from": "communication_channels",
      "to": "artifacts_and_truth_sources",
      "rel": "guards",
      "strength": 0.5
    },
    {
      "from": "communication_channels",
      "to": "meeting_load_and_latency",
      "rel": "reduces",
      "strength": 0.6
    },
    {
      "from": "constitution",
      "to": "governance",
      "rel": "is_part_of",
      "strength": 0.7
    },
    {
      "from": "constitution",
      "to": "policy_system",
      "rel": "enforces",
      "strength": 0.6
    },
    {
      "from": "constitution",
      "to": "quality_gates",
      "rel": "is_enforced_by",
      "strength": 0.5
    },
    {
      "from": "core_decisions",
      "to": "structure",
      "rel": "shapes",
      "strength": 0.9
    },
    {
      "from": "core_decisions",
      "to": "process",
      "rel": "shaped_by",
      "strength": 0.8
    },
    {
      "from": "core_decisions",
      "to": "governance",
      "rel": "constrained_by",
      "strength": 0.7
    },
    {
      "from": "core_decisions",
      "to": "implementation",
      "rel": "realized_by",
      "strength": 0.8
    },
    {
      "from": "core_decisions",
      "to": "communication",
      "rel": "informed_by",
      "strength": 0.6
    },
    {
      "from": "core_decisions",
      "to": "observation_transparency",
      "rel": "evaluated_by",
      "strength": 0.7
    },
    {
      "from": "dashboards_and_queries",
      "to": "signals_and_slos",
      "rel": "is_driven_by",
      "strength": 0.5
    },
    {
      "from": "dashboards_and_queries",
      "to": "review_and_quality",
      "rel": "supports",
      "strength": 0.4
    },
    {
      "from": "data_handling_and_privacy",
      "to": "telemetry_design",
      "rel": "constrains",
      "strength": 0.5
    },
    {
      "from": "data_handling_and_privacy",
      "to": "artifacts_and_truth_sources",
      "rel": "constrains",
      "strength": 0.4
    },
    {
      "from": "data_handling_and_privacy",
      "to": "transparency_and_access",
      "rel": "aligns_with",
      "strength": 0.5
    },
    {
      "from": "decision_process",
      "to": "decision_records",
      "rel": "uses",
      "strength": 0.6
    },
    {
      "from": "decision_process",
      "to": "policy_system",
      "rel": "is_constrained_by",
      "strength": 0.5
    },
    {
      "from": "decision_records",
      "to": "change_control",
      "rel": "supports",
      "strength": 0.6
    },
    {
      "from": "decision_records",
      "to": "architecture_boundaries",
      "rel": "references",
      "strength": 0.5
    },
    {
      "from": "decision_records",
      "to": "interfaces_and_contracts",
      "rel": "references",
      "strength": 0.5
    },
    {
      "from": "decision_records",
      "to": "change_control",
      "rel": "feeds",
      "strength": 0.6
    },
    {
      "from": "dev_secrets_and_env",
      "to": "secrets_and_passwords",
      "rel": "depends_on",
      "strength": 0.6
    },
    {
      "from": "dev_secrets_and_env",
      "to": "quality_gates",
      "rel": "is_enforced_by",
      "strength": 0.5
    },
    {
      "from": "execution",
      "to": "planning_and_work",
      "rel": "is_scheduled_by",
      "strength": 0.8
    },
    {
      "from": "execution",
      "to": "review_and_quality",
      "rel": "produces_for",
      "strength": 0.9
    },
    {
      "from": "execution",
      "to": "specification",
      "rel": "realizes",
      "strength": 0.7
    },
    {
      "from": "execution",
      "to": "runtime_execution_authority",
      "rel": "runs_under",
      "strength": 0.6
    },
    {
      "from": "feedback_and_learning",
      "to": "review_and_quality",
      "rel": "is_yielded_by",
      "strength": 0.7
    },
    {
      "from": "feedback_and_learning",
      "to": "problem_framing",
      "rel": "reframes",
      "strength": 0.7
    },
    {
      "from": "feedback_and_learning",
      "to": "requirements",
      "rel": "updates",
      "strength": 0.6
    },
    {
      "from": "feedback_and_learning",
      "to": "observability_design",
      "rel": "is_enabled_by",
      "strength": 0.6
    },
    {
      "from": "feedback_and_learning",
      "to": "change_control",
      "rel": "drives",
      "strength": 0.6
    },
    {
      "from": "feedback_and_learning",
      "to": "signals_and_slos",
      "rel": "uses",
      "strength": 0.4
    },
    {
      "from": "governance",
      "to": "process",
      "rel": "shapes",
      "strength": 0.6
    },
    {
      "from": "governance",
      "to": "implementation",
      "rel": "constrains",
      "strength": 0.8
    },
    {
      "from": "governance",
      "to": "structure",
      "rel": "protects",
      "strength": 0.6
    },
    {
      "from": "governance",
      "to": "observation_transparency",
      "rel": "depends_on",
      "strength": 0.5
    },
    {
      "from": "governance",
      "to": "communication",
      "rel": "requires",
      "strength": 0.4
    },
    {
      "from": "governance_feedback_loops",
      "to": "feedback_and_learning",
      "rel": "depends_on",
      "strength": 0.6
    },
    {
      "from": "governance_feedback_loops",
      "to": "policy_system",
      "rel": "updates",
      "strength": 0.5
    },
    {
      "from": "governance_feedback_loops",
      "to": "quality_gates",
      "rel": "updates",
      "strength": 0.5
    },
    {
      "from": "implementation",
      "to": "process",
      "rel": "depends_on",
      "strength": 0.5
    },
    {
      "from": "implementation",
      "to": "governance",
      "rel": "constrained_by",
      "strength": 0.7
    },
    {
      "from": "implementation",
      "to": "observation_transparency",
      "rel": "enables",
      "strength": 0.6
    },
    {
      "from": "implementation",
      "to": "structure",
      "rel": "depends_on",
      "strength": 0.7
    },
    {
      "from": "implementation",
      "to": "communication",
      "rel": "reduced_by",
      "strength": 0.4
    },
    {
      "from": "incidents_and_postmortems",
      "to": "actionability_and_ownership",
      "rel": "is_triggered_by",
      "strength": 0.6
    },
    {
      "from": "incidents_and_postmortems",
      "to": "feedback_and_learning",
      "rel": "produces",
      "strength": 0.7
    },
    {
      "from": "incidents_and_postmortems",
      "to": "change_control",
      "rel": "produces",
      "strength": 0.5
    },
    {
      "from": "incidents_and_postmortems",
      "to": "dashboards_and_queries",
      "rel": "is_supported_by",
      "strength": 0.5
    },
    {
      "from": "incidents_and_postmortems",
      "to": "runbooks_and_playbooks",
      "rel": "updates",
      "strength": 0.5
    },
    {
      "from": "interfaces_and_contracts",
      "to": "architecture_boundaries",
      "rel": "is_constrained_by",
      "strength": 0.8
    },
    {
      "from": "interfaces_and_contracts",
      "to": "module_composition",
      "rel": "enables",
      "strength": 0.7
    },
    {
      "from": "interfaces_and_contracts",
      "to": "quality_gates",
      "rel": "is_validated_by",
      "strength": 0.7
    },
    {
      "from": "interfaces_and_contracts",
      "to": "specification",
      "rel": "is_expressed_in",
      "strength": 0.6
    },
    {
      "from": "interfaces_and_contracts",
      "to": "requirements",
      "rel": "is_constrained_by",
      "strength": 0.6
    },
    {
      "from": "knowledge_ops_inbox_and_curation",
      "to": "artifacts_and_truth_sources",
      "rel": "depends_on",
      "strength": 0.5
    },
    {
      "from": "knowledge_ops_inbox_and_curation",
      "to": "quality_gates",
      "rel": "is_guarded_by",
      "strength": 0.4
    },
    {
      "from": "least_privilege_and_access",
      "to": "transparency_and_access",
      "rel": "constrains",
      "strength": 0.6
    },
    {
      "from": "least_privilege_and_access",
      "to": "secrets_and_passwords",
      "rel": "supports",
      "strength": 0.6
    },
    {
      "from": "local_dev_environment",
      "to": "reproducible_builds",
      "rel": "supports",
      "strength": 0.6
    },
    {
      "from": "local_dev_environment",
      "to": "automation_and_scripts",
      "rel": "is_supported_by",
      "strength": 0.5
    },
    {
      "from": "meeting_load_and_latency",
      "to": "communication_channels",
      "rel": "is_reduced_by",
      "strength": 0.6
    },
    {
      "from": "meeting_load_and_latency",
      "to": "quality_gates",
      "rel": "is_reduced_by",
      "strength": 0.5
    },
    {
      "from": "module_composition",
      "to": "interfaces_and_contracts",
      "rel": "is_enabled_by",
      "strength": 0.7
    },
    {
      "from": "module_composition",
      "to": "runtime_execution_authority",
      "rel": "depends_on",
      "strength": 0.6
    },
    {
      "from": "module_composition",
      "to": "quality_gates",
      "rel": "is_enforced_by",
      "strength": 0.7
    },
    {
      "from": "module_composition",
      "to": "planning_and_work",
      "rel": "is_informed_by",
      "strength": 0.5
    },
    {
      "from": "observability_design",
      "to": "runtime_execution_authority",
      "rel": "observes",
      "strength": 0.6
    },
    {
      "from": "observability_design",
      "to": "quality_gates",
      "rel": "validates",
      "strength": 0.5
    },
    {
      "from": "observability_design",
      "to": "change_control",
      "rel": "feeds",
      "strength": 0.6
    },
    {
      "from": "observability_design",
      "to": "feedback_and_learning",
      "rel": "enables",
      "strength": 0.6
    },
    {
      "from": "observability_design",
      "to": "review_and_quality",
      "rel": "supports",
      "strength": 0.5
    },
    {
      "from": "observation_transparency",
      "to": "process",
      "rel": "improves",
      "strength": 0.7
    },
    {
      "from": "observation_transparency",
      "to": "governance",
      "rel": "enables",
      "strength": 0.5
    },
    {
      "from": "observation_transparency",
      "to": "implementation",
      "rel": "depends_on",
      "strength": 0.6
    },
    {
      "from": "observation_transparency",
      "to": "structure",
      "rel": "evaluated_by",
      "strength": 0.4
    },
    {
      "from": "observation_transparency",
      "to": "communication",
      "rel": "informs",
      "strength": 0.3
    },
    {
      "from": "ownership_and_raci",
      "to": "actionability_and_ownership",
      "rel": "enables",
      "strength": 0.6
    },
    {
      "from": "ownership_and_raci",
      "to": "change_control",
      "rel": "supports",
      "strength": 0.5
    },
    {
      "from": "planning_and_work",
      "to": "specification",
      "rel": "is_decomposed_from",
      "strength": 0.8
    },
    {
      "from": "planning_and_work",
      "to": "execution",
      "rel": "schedules",
      "strength": 0.8
    },
    {
      "from": "planning_and_work",
      "to": "review_and_quality",
      "rel": "is_adjusted_by",
      "strength": 0.6
    },
    {
      "from": "planning_and_work",
      "to": "module_composition",
      "rel": "respects",
      "strength": 0.6
    },
    {
      "from": "policy_system",
      "to": "quality_gates",
      "rel": "is_enforced_by",
      "strength": 0.7
    },
    {
      "from": "policy_system",
      "to": "change_control",
      "rel": "is_versioned_by",
      "strength": 0.6
    },
    {
      "from": "problem_framing",
      "to": "requirements",
      "rel": "informs",
      "strength": 0.8
    },
    {
      "from": "problem_framing",
      "to": "specification",
      "rel": "anchors",
      "strength": 0.6
    },
    {
      "from": "problem_framing",
      "to": "feedback_and_learning",
      "rel": "is_refined_by",
      "strength": 0.7
    },
    {
      "from": "problem_framing",
      "to": "architecture_boundaries",
      "rel": "implies",
      "strength": 0.5
    },
    {
      "from": "process",
      "to": "communication",
      "rel": "depends_on",
      "strength": 0.7
    },
    {
      "from": "process",
      "to": "governance",
      "rel": "constrained_by",
      "strength": 0.6
    },
    {
      "from": "process",
      "to": "implementation",
      "rel": "realized_by",
      "strength": 0.5
    },
    {
      "from": "process",
      "to": "observation_transparency",
      "rel": "evaluated_by",
      "strength": 0.7
    },
    {
      "from": "process",
      "to": "structure",
      "rel": "coevolves_with",
      "strength": 0.6
    },
    {
      "from": "quality_gates",
      "to": "architecture_boundaries",
      "rel": "enforces",
      "strength": 0.7
    },
    {
      "from": "quality_gates",
      "to": "interfaces_and_contracts",
      "rel": "enforces",
      "strength": 0.7
    },
    {
      "from": "quality_gates",
      "to": "module_composition",
      "rel": "enforces",
      "strength": 0.7
    },
    {
      "from": "quality_gates",
      "to": "change_control",
      "rel": "supports",
      "strength": 0.6
    },
    {
      "from": "quality_gates",
      "to": "review_and_quality",
      "rel": "reinforces",
      "strength": 0.7
    },
    {
      "from": "quality_gates",
      "to": "meeting_load_and_latency",
      "rel": "reduces",
      "strength": 0.4
    },
    {
      "from": "quality_gates",
      "to": "signals_and_slos",
      "rel": "uses",
      "strength": 0.4
    },
    {
      "from": "quality_gates",
      "to": "supply_chain_security",
      "rel": "enforces",
      "strength": 0.5
    },
    {
      "from": "quality_gates",
      "to": "automation_and_scripts",
      "rel": "is_implemented_by",
      "strength": 0.5
    },
    {
      "from": "quality_gates",
      "to": "policy_system",
      "rel": "enforces",
      "strength": 0.5
    },
    {
      "from": "reproducible_builds",
      "to": "quality_gates",
      "rel": "is_enforced_by",
      "strength": 0.6
    },
    {
      "from": "reproducible_builds",
      "to": "supply_chain_security",
      "rel": "reduces",
      "strength": 0.4
    },
    {
      "from": "requirements",
      "to": "problem_framing",
      "rel": "is_informed_by",
      "strength": 0.8
    },
    {
      "from": "requirements",
      "to": "specification",
      "rel": "constrains",
      "strength": 0.9
    },
    {
      "from": "requirements",
      "to": "planning_and_work",
      "rel": "shapes",
      "strength": 0.7
    },
    {
      "from": "requirements",
      "to": "interfaces_and_contracts",
      "rel": "shapes",
      "strength": 0.6
    },
    {
      "from": "review_and_quality",
      "to": "execution",
      "rel": "consumes",
      "strength": 0.9
    },
    {
      "from": "review_and_quality",
      "to": "specification",
      "rel": "validates",
      "strength": 0.7
    },
    {
      "from": "review_and_quality",
      "to": "feedback_and_learning",
      "rel": "yields",
      "strength": 0.7
    },
    {
      "from": "review_and_quality",
      "to": "quality_gates",
      "rel": "is_supported_by",
      "strength": 0.7
    },
    {
      "from": "review_and_quality",
      "to": "observability_design",
      "rel": "requires",
      "strength": 0.5
    },
    {
      "from": "risk_and_compliance",
      "to": "threat_modeling",
      "rel": "aligns_with",
      "strength": 0.5
    },
    {
      "from": "risk_and_compliance",
      "to": "least_privilege_and_access",
      "rel": "constrains",
      "strength": 0.4
    },
    {
      "from": "risk_and_compliance",
      "to": "security_incidents",
      "rel": "is_informed_by",
      "strength": 0.4
    },
    {
      "from": "runbooks_and_playbooks",
      "to": "actionability_and_ownership",
      "rel": "is_required_by",
      "strength": 0.6
    },
    {
      "from": "runbooks_and_playbooks",
      "to": "incidents_and_postmortems",
      "rel": "supports",
      "strength": 0.6
    },
    {
      "from": "runbooks_and_playbooks",
      "to": "dashboards_and_queries",
      "rel": "is_supported_by",
      "strength": 0.6
    },
    {
      "from": "runbooks_and_playbooks",
      "to": "signals_and_slos",
      "rel": "uses",
      "strength": 0.4
    },
    {
      "from": "runtime_execution_authority",
      "to": "module_composition",
      "rel": "is_enabled_by",
      "strength": 0.6
    },
    {
      "from": "runtime_execution_authority",
      "to": "observability_design",
      "rel": "requires",
      "strength": 0.6
    },
    {
      "from": "runtime_execution_authority",
      "to": "quality_gates",
      "rel": "is_covered_by",
      "strength": 0.6
    },
    {
      "from": "runtime_execution_authority",
      "to": "execution",
      "rel": "governs",
      "strength": 0.6
    },
    {
      "from": "runtime_execution_authority",
      "to": "sandboxing_and_isolation",
      "rel": "is_constrained_by",
      "strength": 0.5
    },
    {
      "from": "sandboxing_and_isolation",
      "to": "runtime_execution_authority",
      "rel": "constrains",
      "strength": 0.5
    },
    {
      "from": "sandboxing_and_isolation",
      "to": "supply_chain_security",
      "rel": "reduces",
      "strength": 0.4
    },
    {
      "from": "secrets_and_passwords",
      "to": "least_privilege_and_access",
      "rel": "requires",
      "strength": 0.6
    },
    {
      "from": "secrets_and_passwords",
      "to": "quality_gates",
      "rel": "is_guarded_by",
      "strength": 0.5
    },
    {
      "from": "secrets_and_passwords",
      "to": "dev_secrets_and_env",
      "rel": "is_applied_in",
      "strength": 0.5
    },
    {
      "from": "security_incidents",
      "to": "signals_and_slos",
      "rel": "depends_on",
      "strength": 0.4
    },
    {
      "from": "security_incidents",
      "to": "actionability_and_ownership",
      "rel": "depends_on",
      "strength": 0.5
    },
    {
      "from": "security_incidents",
      "to": "runbooks_and_playbooks",
      "rel": "uses",
      "strength": 0.5
    },
    {
      "from": "security_incidents",
      "to": "change_control",
      "rel": "produces",
      "strength": 0.5
    },
    {
      "from": "security_incidents",
      "to": "risk_and_compliance",
      "rel": "updates",
      "strength": 0.4
    },
    {
      "from": "security_safety",
      "to": "secrets_and_passwords",
      "rel": "expands_to",
      "strength": 0.6
    },
    {
      "from": "security_safety",
      "to": "sandboxing_and_isolation",
      "rel": "expands_to",
      "strength": 0.6
    },
    {
      "from": "security_safety",
      "to": "least_privilege_and_access",
      "rel": "expands_to",
      "strength": 0.6
    },
    {
      "from": "shared_language_and_models",
      "to": "artifacts_and_truth_sources",
      "rel": "enables",
      "strength": 0.6
    },
    {
      "from": "shared_language_and_models",
      "to": "ambiguity_and_alignment",
      "rel": "reduces",
      "strength": 0.6
    },
    {
      "from": "signals_and_slos",
      "to": "feedback_and_learning",
      "rel": "informs",
      "strength": 0.6
    },
    {
      "from": "signals_and_slos",
      "to": "quality_gates",
      "rel": "feeds",
      "strength": 0.5
    },
    {
      "from": "signals_and_slos",
      "to": "quality_gates",
      "rel": "drives",
      "strength": 0.4
    },
    {
      "from": "specification",
      "to": "requirements",
      "rel": "is_constrained_by",
      "strength": 0.9
    },
    {
      "from": "specification",
      "to": "planning_and_work",
      "rel": "decomposes_into",
      "strength": 0.8
    },
    {
      "from": "specification",
      "to": "review_and_quality",
      "rel": "is_validated_by",
      "strength": 0.7
    },
    {
      "from": "specification",
      "to": "change_control",
      "rel": "is_controlled_by",
      "strength": 0.7
    },
    {
      "from": "specification",
      "to": "interfaces_and_contracts",
      "rel": "includes",
      "strength": 0.6
    },
    {
      "from": "specification",
      "to": "artifacts_and_truth_sources",
      "rel": "is_a_truth_source_for",
      "strength": 0.5
    },
    {
      "from": "structure",
      "to": "process",
      "rel": "coevolves_with",
      "strength": 0.6
    },
    {
      "from": "structure",
      "to": "governance",
      "rel": "constrained_by",
      "strength": 0.6
    },
    {
      "from": "structure",
      "to": "implementation",
      "rel": "realized_by",
      "strength": 0.7
    },
    {
      "from": "structure",
      "to": "observation_transparency",
      "rel": "evaluated_by",
      "strength": 0.4
    },
    {
      "from": "structure",
      "to": "communication",
      "rel": "depends_on",
      "strength": 0.5
    },
    {
      "from": "supply_chain_security",
      "to": "quality_gates",
      "rel": "is_enforced_by",
      "strength": 0.6
    },
    {
      "from": "supply_chain_security",
      "to": "module_composition",
      "rel": "constrains",
      "strength": 0.4
    },
    {
      "from": "telemetry_design",
      "to": "observability_design",
      "rel": "is_part_of",
      "strength": 0.7
    },
    {
      "from": "telemetry_design",
      "to": "runtime_execution_authority",
      "rel": "supports",
      "strength": 0.5
    },
    {
      "from": "telemetry_design",
      "to": "feedback_and_learning",
      "rel": "enables",
      "strength": 0.5
    },
    {
      "from": "threat_modeling",
      "to": "architecture_boundaries",
      "rel": "informs",
      "strength": 0.5
    },
    {
      "from": "threat_modeling",
      "to": "quality_gates",
      "rel": "informs",
      "strength": 0.5
    },
    {
      "from": "threat_modeling",
      "to": "decision_records",
      "rel": "triggers",
      "strength": 0.4
    },
    {
      "from": "tooling_dev_environment",
      "to": "local_dev_environment",
      "rel": "expands_to",
      "strength": 0.6
    },
    {
      "from": "tooling_dev_environment",
      "to": "automation_and_scripts",
      "rel": "expands_to",
      "strength": 0.6
    },
    {
      "from": "tooling_dev_environment",
      "to": "ai_assisted_workflow",
      "rel": "expands_to",
      "strength": 0.6
    },
    {
      "from": "transparency_and_access",
      "to": "telemetry_design",
      "rel": "constrains",
      "strength": 0.5
    },
    {
      "from": "transparency_and_access",
      "to": "change_control",
      "rel": "is_part_of",
      "strength": 0.4
    },
    {
      "from": "transparency_and_access",
      "to": "artifacts_and_truth_sources",
      "rel": "constrains",
      "strength": 0.3
    },
    {
      "from": "transparency_and_access",
      "to": "data_handling_and_privacy",
      "rel": "requires",
      "strength": 0.5
    },
    {
      "from": "transparency_and_access",
      "to": "auditability_and_traceability",
      "rel": "supports",
      "strength": 0.4
    }
  ]
}